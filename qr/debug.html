<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>QR Debug v2</title>
    <style>
        body {
            background: #1a1a2e;
            color: #fff;
            font-family: monospace;
            padding: 20px;
        }

        canvas {
            border: 1px solid #444;
            margin: 5px;
        }

        pre {
            background: #000;
            padding: 10px;
            max-height: 400px;
            overflow: auto;
            font-size: 11px;
        }

        .row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .box {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
        }

        button {
            padding: 10px 20px;
            background: #00ff88;
            color: #000;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
        }

        input {
            padding: 10px;
            font-size: 14px;
            width: 300px;
        }

        .success {
            color: #00ff88;
        }

        .fail {
            color: #ff4757;
        }
    </style>
</head>

<body>
    <h1>QR Debug v2</h1>

    <div class="box">
        <input type="text" id="input" value="Hello" placeholder="Enter text to encode">
        <button id="test">Test</button>
        <button id="testSimple">Test Simple Grid</button>
    </div>

    <div class="row">
        <div class="box">
            <h3>1. Generated QR</h3>
            <canvas id="qr"></canvas>
        </div>
        <div class="box">
            <h3>2. Binary</h3>
            <canvas id="binary"></canvas>
        </div>
        <div class="box">
            <h3>3. Detected Patterns</h3>
            <canvas id="patterns"></canvas>
        </div>
        <div class="box">
            <h3>4. Sampled Grid</h3>
            <canvas id="sampled"></canvas>
        </div>
    </div>

    <div class="box">
        <h3>Debug Log</h3>
        <pre id="log"></pre>
    </div>

    <script src="qr-encoder.js"></script>
    <script>
        const qrCanvas = document.getElementById('qr');
        const binaryCanvas = document.getElementById('binary');
        const patternsCanvas = document.getElementById('patterns');
        const sampledCanvas = document.getElementById('sampled');
        const logPre = document.getElementById('log');

        function log(msg) { logPre.textContent += msg + '\n'; }
        function clearLog() { logPre.textContent = ''; }

        // ===== INLINE DECODER FOR DEBUGGING =====

        function binarize(imageData, width, height) {
            const binary = new Uint8Array(width * height);
            for (let i = 0; i < width * height; i++) {
                const gray = 0.299 * imageData[i * 4] + 0.587 * imageData[i * 4 + 1] + 0.114 * imageData[i * 4 + 2];
                binary[i] = gray < 128 ? 1 : 0;
            }
            return binary;
        }

        function findFinderPatterns(binary, width, height) {
            const candidates = [];

            for (let y = 0; y < height; y++) {
                let state = binary[y * width] === 1 ? 0 : -1;
                const counts = [0, 0, 0, 0, 0];

                for (let x = 0; x < width; x++) {
                    const pixel = binary[y * width + x];
                    const expected = state % 2;

                    if (state === -1) {
                        if (pixel === 1) { state = 0; counts[0] = 1; }
                    } else if (pixel === expected) {
                        counts[state]++;
                    } else {
                        if (state === 4) {
                            const total = counts[0] + counts[1] + counts[2] + counts[3] + counts[4];
                            const unit = total / 7;
                            const tol = unit * 0.5;
                            if (total >= 7 &&
                                Math.abs(counts[0] - unit) <= tol &&
                                Math.abs(counts[1] - unit) <= tol &&
                                Math.abs(counts[2] - 3 * unit) <= tol * 1.5 &&
                                Math.abs(counts[3] - unit) <= tol &&
                                Math.abs(counts[4] - unit) <= tol) {
                                const cx = x - counts[4] - counts[3] - counts[2] / 2;
                                candidates.push({ x: cx, y, width: total });
                            }
                            counts[0] = counts[2]; counts[1] = counts[3]; counts[2] = counts[4];
                            counts[3] = 1; counts[4] = 0; state = 3;
                        } else {
                            state++;
                            counts[state] = 1;
                        }
                    }
                }
            }

            // Cluster
            const clusters = [];
            for (const p of candidates) {
                let merged = false;
                for (const c of clusters) {
                    if (Math.hypot(p.x - c.x, p.y - c.y) < p.width * 0.5) {
                        c.x = (c.x * c.n + p.x) / (c.n + 1);
                        c.y = (c.y * c.n + p.y) / (c.n + 1);
                        c.width = (c.width * c.n + p.width) / (c.n + 1);
                        c.n++;
                        merged = true;
                        break;
                    }
                }
                if (!merged) clusters.push({ x: p.x, y: p.y, width: p.width, n: 1 });
            }
            return clusters.filter(c => c.n >= 3).sort((a, b) => b.n - a.n);
        }

        function orderPatterns(pts) {
            if (pts.length < 3) return null;
            const p = pts.slice(0, 3);
            p.sort((a, b) => (a.x + a.y) - (b.x + b.y));
            const topLeft = p[0];
            let topRight, bottomLeft;
            if (p[1].x > p[2].x) { topRight = p[1]; bottomLeft = p[2]; }
            else { topRight = p[2]; bottomLeft = p[1]; }

            const v1x = topRight.x - topLeft.x, v1y = topRight.y - topLeft.y;
            const v2x = bottomLeft.x - topLeft.x, v2y = bottomLeft.y - topLeft.y;
            if (v1x * v2y - v1y * v2x < 0) [topRight, bottomLeft] = [bottomLeft, topRight];

            return { topLeft, topRight, bottomLeft };
        }

        function sampleGrid(binary, width, height, patterns, size) {
            const { topLeft, topRight, bottomLeft } = patterns;
            const moduleCount = size - 7;

            const dxR = (topRight.x - topLeft.x) / moduleCount;
            const dyR = (topRight.y - topLeft.y) / moduleCount;
            const dxD = (bottomLeft.x - topLeft.x) / moduleCount;
            const dyD = (bottomLeft.y - topLeft.y) / moduleCount;

            const originX = topLeft.x - 3.5 * dxR - 3.5 * dxD;
            const originY = topLeft.y - 3.5 * dyR - 3.5 * dyD;

            const matrix = [];
            for (let r = 0; r < size; r++) {
                const row = [];
                for (let c = 0; c < size; c++) {
                    const px = originX + (c + 0.5) * dxR + (r + 0.5) * dxD;
                    const py = originY + (c + 0.5) * dyR + (r + 0.5) * dyD;
                    const ix = Math.round(px), iy = Math.round(py);
                    row.push(ix >= 0 && ix < width && iy >= 0 && iy < height ? binary[iy * width + ix] : 0);
                }
                matrix.push(row);
            }
            return { matrix, originX, originY, dxR, dyR, dxD, dyD };
        }

        function readFormat(matrix) {
            let bits = 0;
            for (let c = 0; c <= 5; c++) bits = (bits << 1) | matrix[8][c];
            bits = (bits << 1) | matrix[8][7];
            bits = (bits << 1) | matrix[8][8];
            bits = (bits << 1) | matrix[7][8];
            for (let r = 5; r >= 0; r--) bits = (bits << 1) | matrix[r][8];
            bits ^= 0x5412;
            return { ec: ['M', 'L', 'H', 'Q'][(bits >> 13) & 3], mask: (bits >> 10) & 7 };
        }

        function isFunc(r, c, size) {
            if (r < 9 && c < 9) return true;
            if (r < 9 && c >= size - 8) return true;
            if (r >= size - 8 && c < 9) return true;
            if (r === 6 || c === 6) return true;
            return false;
        }

        function unmask(matrix, size, mask) {
            const fns = [
                (r, c) => (r + c) % 2 === 0,
                (r, c) => r % 2 === 0,
                (r, c) => c % 3 === 0,
                (r, c) => (r + c) % 3 === 0,
                (r, c) => (Math.floor(r / 2) + Math.floor(c / 3)) % 2 === 0,
                (r, c) => ((r * c) % 2 + (r * c) % 3) === 0,
                (r, c) => ((r * c) % 2 + (r * c) % 3) % 2 === 0,
                (r, c) => ((r + c) % 2 + (r * c) % 3) % 2 === 0
            ];
            const fn = fns[mask];
            return matrix.map((row, r) => row.map((val, c) => !isFunc(r, c, size) && fn(r, c) ? val ^ 1 : val));
        }

        function extractBits(matrix, size) {
            const bits = [];
            let up = true;
            for (let col = size - 1; col >= 1; col -= 2) {
                if (col === 6) col = 5;
                for (let i = 0; i < size; i++) {
                    const row = up ? size - 1 - i : i;
                    if (!isFunc(row, col, size)) bits.push(matrix[row][col]);
                    if (col > 0 && !isFunc(row, col - 1, size)) bits.push(matrix[row][col - 1]);
                }
                up = !up;
            }
            return bits;
        }

        function decodeBits(bits) {
            let i = 0, result = '';
            const read = n => { let v = 0; for (let j = 0; j < n && i < bits.length; j++) v = (v << 1) | bits[i++]; return v; };
            while (i < bits.length - 4) {
                const mode = read(4);
                if (mode === 0) break;
                if (mode === 4) {
                    const count = read(8);
                    for (let j = 0; j < count; j++) { const b = read(8); if (b) result += String.fromCharCode(b); }
                } else break;
            }
            return result;
        }

        // ===== RUN TEST =====

        document.getElementById('test').onclick = () => {
            clearLog();
            const text = document.getElementById('input').value;
            log(`Input: "${text}"`);

            try {
                // Step 1: Encode
                const qrData = QREncoder.generate(text, 'M');
                const size = qrData.size;
                const version = (size - 17) / 4;
                log(`Encoded: version ${version}, size ${size}x${size}`);

                // Render with scale 4
                QREncoder.renderToCanvas(qrData, qrCanvas, { scale: 4, margin: 4 });
                log(`Canvas: ${qrCanvas.width}x${qrCanvas.height}`);

                // Step 2: Get image data and binarize
                const ctx = qrCanvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, qrCanvas.width, qrCanvas.height);
                const binary = binarize(imageData.data, qrCanvas.width, qrCanvas.height);

                // Show binary
                binaryCanvas.width = qrCanvas.width;
                binaryCanvas.height = qrCanvas.height;
                const binCtx = binaryCanvas.getContext('2d');
                const binData = binCtx.createImageData(qrCanvas.width, qrCanvas.height);
                for (let i = 0; i < binary.length; i++) {
                    const v = binary[i] ? 0 : 255;
                    binData.data[i * 4] = binData.data[i * 4 + 1] = binData.data[i * 4 + 2] = v;
                    binData.data[i * 4 + 3] = 255;
                }
                binCtx.putImageData(binData, 0, 0);

                // Step 3: Find patterns
                const patterns = findFinderPatterns(binary, qrCanvas.width, qrCanvas.height);
                log(`Found ${patterns.length} finder patterns`);
                for (const p of patterns.slice(0, 5)) {
                    log(`  (${p.x.toFixed(1)}, ${p.y.toFixed(1)}) w=${p.width.toFixed(1)} n=${p.n}`);
                }

                // Show patterns
                patternsCanvas.width = qrCanvas.width;
                patternsCanvas.height = qrCanvas.height;
                const patCtx = patternsCanvas.getContext('2d');
                patCtx.drawImage(binaryCanvas, 0, 0);
                const colors = ['#ff0000', '#00ff00', '#0000ff'];
                for (let i = 0; i < Math.min(3, patterns.length); i++) {
                    const p = patterns[i];
                    patCtx.strokeStyle = colors[i];
                    patCtx.lineWidth = 2;
                    patCtx.strokeRect(p.x - p.width / 2, p.y - p.width / 2, p.width, p.width);
                    patCtx.fillStyle = colors[i];
                    patCtx.beginPath();
                    patCtx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    patCtx.fill();
                }

                if (patterns.length < 3) {
                    log('ERROR: Need at least 3 finder patterns');
                    return;
                }

                // Step 4: Order patterns
                const ordered = orderPatterns(patterns);
                log(`Ordered: TL=(${ordered.topLeft.x.toFixed(1)}, ${ordered.topLeft.y.toFixed(1)}), TR=(${ordered.topRight.x.toFixed(1)}, ${ordered.topRight.y.toFixed(1)}), BL=(${ordered.bottomLeft.x.toFixed(1)}, ${ordered.bottomLeft.y.toFixed(1)})`);

                // Calculate expected positions
                const margin = 4 * 4; // 4 modules margin * scale 4
                const modulePixels = 4; // scale
                const expectedTL = { x: margin + 3.5 * modulePixels, y: margin + 3.5 * modulePixels };
                const expectedTR = { x: margin + (size - 3.5) * modulePixels, y: margin + 3.5 * modulePixels };
                const expectedBL = { x: margin + 3.5 * modulePixels, y: margin + (size - 3.5) * modulePixels };
                log(`Expected: TL=(${expectedTL.x}, ${expectedTL.y}), TR=(${expectedTR.x}, ${expectedTR.y}), BL=(${expectedBL.x}, ${expectedBL.y})`);

                // Step 5: Sample grid
                const { matrix, originX, originY, dxR, dyR, dxD, dyD } = sampleGrid(binary, qrCanvas.width, qrCanvas.height, ordered, size);
                log(`Sample origin: (${originX.toFixed(1)}, ${originY.toFixed(1)})`);
                log(`Vectors: dR=(${dxR.toFixed(2)}, ${dyR.toFixed(2)}), dD=(${dxD.toFixed(2)}, ${dyD.toFixed(2)})`);

                // Show sampled grid
                sampledCanvas.width = size * 4;
                sampledCanvas.height = size * 4;
                const sampCtx = sampledCanvas.getContext('2d');
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        sampCtx.fillStyle = matrix[r][c] ? '#000' : '#fff';
                        sampCtx.fillRect(c * 4, r * 4, 4, 4);
                    }
                }

                // Log top-left of matrix
                log('Sampled top-left 9x9:');
                for (let r = 0; r < 9; r++) {
                    log('  ' + matrix[r].slice(0, 9).map(v => v ? '█' : '░').join(''));
                }

                // Step 6: Read format and decode
                const format = readFormat(matrix);
                log(`Format: EC=${format.ec}, mask=${format.mask}`);

                const unmasked = unmask(matrix, size, format.mask);
                const bits = extractBits(unmasked, size);
                log(`Extracted ${bits.length} bits`);

                const decoded = decodeBits(bits);
                log(`Decoded: "${decoded}"`);

                if (decoded === text) {
                    log('✅ SUCCESS!');
                } else {
                    log(`❌ FAIL: Expected "${text}", got "${decoded}"`);
                }

            } catch (e) {
                log(`ERROR: ${e.message}`);
                console.error(e);
            }
        };

        // Test with simple expected coordinates
        document.getElementById('testSimple').onclick = () => {
            clearLog();
            const text = 'Test';
            log('Testing with known coordinates...');

            const qrData = QREncoder.generate(text, 'M');
            const size = qrData.size; // 21 for version 1
            QREncoder.renderToCanvas(qrData, qrCanvas, { scale: 4, margin: 4 });

            const ctx = qrCanvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, qrCanvas.width, qrCanvas.height);
            const binary = binarize(imageData.data, qrCanvas.width, qrCanvas.height);

            // Calculate expected finder pattern centers
            const margin = 16; // 4 modules * 4 pixels
            const moduleSize = 4;

            // TL center: margin + 3.5 modules
            const tlX = margin + 3.5 * moduleSize; // 16 + 14 = 30
            const tlY = margin + 3.5 * moduleSize; // 30

            // TR center: margin + (size - 3.5) modules
            const trX = margin + (size - 3.5) * moduleSize; // 16 + 17.5*4 = 16 + 70 = 86
            const trY = margin + 3.5 * moduleSize; // 30

            // BL center
            const blX = margin + 3.5 * moduleSize; // 30
            const blY = margin + (size - 3.5) * moduleSize; // 86

            log(`Expected centers: TL=(${tlX}, ${tlY}), TR=(${trX}, ${trY}), BL=(${blX}, ${blY})`);

            // Use these exact coordinates
            const ordered = {
                topLeft: { x: tlX, y: tlY },
                topRight: { x: trX, y: trY },
                bottomLeft: { x: blX, y: blY }
            };

            const { matrix } = sampleGrid(binary, qrCanvas.width, qrCanvas.height, ordered, size);

            // Show sampled grid
            sampledCanvas.width = size * 4;
            sampledCanvas.height = size * 4;
            const sampCtx = sampledCanvas.getContext('2d');
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    sampCtx.fillStyle = matrix[r][c] ? '#000' : '#fff';
                    sampCtx.fillRect(c * 4, r * 4, 4, 4);
                }
            }

            log('Sampled top-left 9x9:');
            for (let r = 0; r < 9; r++) {
                log('  ' + matrix[r].slice(0, 9).map(v => v ? '█' : '░').join(''));
            }

            const format = readFormat(matrix);
            log(`Format: EC=${format.ec}, mask=${format.mask}`);

            const unmasked = unmask(matrix, size, format.mask);
            const bits = extractBits(unmasked, size);
            const decoded = decodeBits(bits);
            log(`Decoded: "${decoded}"`);

            if (decoded === text) {
                log('✅ SUCCESS with known coordinates!');
            } else {
                log(`❌ FAIL: Expected "${text}", got "${decoded}"`);
            }
        };
    </script>
</body>

</html>