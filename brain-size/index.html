<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Hominid Brain Size Evolution</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #333333;
            --border-color: #cccccc;
            --accent-color: #2c3e50;
            --map-land: #e0e0e0;
            --map-ocean: #ffffff;
            --map-stroke: #999999;
        }

        body {
            margin: 0;
            padding: 20px;
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
        }

        header {
            width: 100%;
            max-width: 1400px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            border-bottom: 2px solid var(--text-color);
            padding-bottom: 10px;
        }

        h1 {
            margin: 0;
            font-size: 24px;
            font-weight: 700;
        }

        .citation {
            font-size: 12px;
            color: #666;
        }

        #controls {
            width: 100%;
            max-width: 1400px;
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 10px;
            background: #f9f9f9;
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
            font-size: 14px;
        }

        /* Language Button in Header */
        #lang-btn {
            background: none;
            border: 1px solid #999;
            color: #666;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            margin-left: 10px;
        }

        #lang-btn:hover {
            background: #eee;
            color: #333;
        }

        button.control-btn {
            padding: 6px 16px;
            cursor: pointer;
            font-size: 14px;
            background: white;
            border: 1px solid var(--text-color);
            border-radius: 2px;
            transition: background 0.2s;
        }

        button.control-btn:hover {
            background: #eee;
        }

        button.control-btn:active {
            background: #ddd;
        }

        .slider-container {
            display: flex;
            align-items: center;
            flex-grow: 1;
            gap: 15px;
            position: relative;
            height: 40px;
        }

        /* Timeline Track Container */
        .timeline-track-container {
            flex-grow: 1;
            position: relative;
            height: 100%;
            display: flex;
            align-items: center;
            user-select: none;
            /* Prevent text selection */
            -webkit-user-select: none;
        }

        /* The actual range input - Top Layer */
        input[type=range] {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
            z-index: 20;
            /* Highest priority for interaction */
            margin: 0;
        }

        /* Visual Track */
        .timeline-track {
            position: absolute;
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            pointer-events: none;
        }

        /* Progress Fill */
        .timeline-progress {
            position: absolute;
            height: 6px;
            background: var(--accent-color);
            border-radius: 3px;
            pointer-events: none;
            width: 0%;
        }

        /* Thumb / Knob */
        .timeline-thumb {
            position: absolute;
            width: 16px;
            height: 16px;
            background: var(--accent-color);
            border: 2px solid white;
            border-radius: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            /* transition removed for instant response */
        }

        .event-marker {
            position: absolute;
            width: 2px;
            height: 10px;
            background: #888;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
            /* Below input */
            pointer-events: none;
        }

        .event-marker.major {
            height: 14px;
            width: 2px;
            background: #555;
        }

        /* JS-driven Hover State */
        .event-marker.active-hover::after {
            content: attr(data-label);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            margin-bottom: 5px;
            pointer-events: none;
            z-index: 30;
            /* Above everything */
        }

        /* Removed native :hover::after since input blocks it */

        .value-display {
            font-family: "Courier New", monospace;
            font-weight: bold;
            min-width: 100px;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        /* Timeline Intervals */
        /* Moved to Graph SVG */

        #main-view {
            display: flex;
            flex-direction: column;
            /* Vertical Stack */
            width: 100%;
            max-width: 1400px;
            height: calc(100% - 140px);
            gap: 10px;
            overflow: hidden;
            /* Prevent body scroll if content fits */
            min-height: 0;
        }

        #map-container,
        #graph-container {
            flex: 1;
            /* Equal 50/50 split vertical */
            border: 1px solid var(--border-color);
            position: relative;
            background: white;
            overflow: hidden;
            min-height: 0;
            /* Enable flex shrinking */
            transition: all 0.3s ease;
        }

        #map-container {
            background: var(--map-ocean);
        }

        .hidden {
            display: none !important;
        }

        /* Tooltip */
        #tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #333;
            padding: 8px;
            font-size: 12px;
            pointer-events: none;
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            display: none;
            z-index: 100;
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .tooltip-label {
            font-weight: bold;
            color: #666;
        }

        /* D3 Styles */
        .graticule {
            fill: none;
            stroke: #ccc;
            stroke-width: 0.5px;
            stroke-opacity: 0.5;
        }

        .country {
            fill: var(--map-land);
            stroke: var(--map-stroke);
            stroke-width: 0.5px;
        }

        .data-point {
            cursor: pointer;
            transition: r 0.2s, stroke-width 0.2s;
        }

        .data-point:hover {
            stroke: #000;
        }

        .highlighted-point {
            stroke: #d00 !important;
            fill: #ff0000 !important;
            fill-opacity: 1 !important;
        }

        .active-dot {
            cursor: pointer;
        }

        .active-dot:hover {
            stroke: #000;
            stroke-width: 2px;
        }

        .active-dot.selected {
            stroke: #d00;
            stroke-width: 2px;
            fill: #d00;
        }

        .axis-label {
            font-size: 12px;
            font-style: italic;
        }

        .axis line,
        .axis path {
            stroke: #333;
        }

        .axis text {
            fill: #333;
            font-family: sans-serif;
            font-size: 10px;
        }

        .timewindow-line {
            stroke: #d00;
            stroke-width: 1.5px;
            stroke-dasharray: 4 2;
        }

        /* Guide Lines for Graph Cursor */
        .guide-line {
            stroke: #999;
            stroke-width: 1px;
            stroke-dasharray: 4 4;
            pointer-events: none;
            /* Ignore mouse events so they pass through */
            display: none;
        }

        .legend-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border: 1px solid #ccc;
            font-size: 11px;
            pointer-events: none;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            user-select: none;
        }
    </style>
</head>

<body>
    <header>
        <div>
            <h1 id="title-text">Hominid Brain Size Evolution</h1>
            <div class="citation" id="citation-text">Data source: brain-size-list_2.csv | Visualization: D3.js v7</div>
        </div>
        <div style="text-align: right; font-size: 12px;">
            <span id="stats-display">Loaded 0 specimens</span>
            <button id="lang-btn">EN/JA</button>
        </div>
    </header>

    <div id="controls">
        <button id="start-btn" class="control-btn" title="Go to Start">⏮</button>
        <button id="play-pause-btn" class="control-btn">Play</button>
        <button id="end-btn" class="control-btn" title="Go to End">⏭</button>
        <div class="slider-container" style="align-items: flex-end; padding-bottom: 10px;">
            <span style="font-weight: bold; margin-bottom: 10px;" id="time-label">Time:</span>

            <div class="timeline-track-container" id="timeline-track-container" style="height: 30px;">
                <input type="range" id="time-slider" min="0" max="1000" value="0" step="0.01">
                <div class="timeline-track"></div>
                <div class="timeline-progress" id="timeline-progress"></div>
                <div class="markers-container" id="markers-container"></div>
                <div class="timeline-thumb" id="timeline-thumb"></div>
            </div>

            <span class="value-display" id="time-display" style="margin-bottom: 10px;">10.00 Ma</span>
        </div>
        <div style="flex-grow:1"></div> <!-- Spacer -->
        <button id="toggle-map-btn" class="control-btn" style="width: auto; padding: 0 10px;">Hide Map</button>
        <button id="toggle-graph-btn" class="control-btn" style="width: auto; padding: 0 10px;">Hide Graph</button>
        <label class="toggle-label">
            <input type="checkbox" id="scaling-toggle">
            <span id="legacy-label">Legacy Scaling</span>
        </label>
    </div>

    <div id="main-view">
        <div id="map-container">
            <div class="legend-container" id="map-legend"></div>
        </div>
        <div id="graph-container"></div>
    </div>

    <div id="tooltip"></div>

    <script>
        // Localization
        const i18n = {
            en: {
                title: "Hominid Brain Size Evolution",
                citation: "Data source: brain-size-list_2.csv | Visualization: D3.js v7",
                stats: "Loaded {n} specimens",
                play: "Play",
                pause: "Pause",
                reset: "Reset",
                time: "Time",
                legacy: "Legacy Scaling",
                ageAxis: "Age (Million Years Ago)",
                sizeAxis: "Cranial Capacity (cc)",
                legendTitle: "Cranial Capacity (cc)",
                tooltipName: "Name",
                tooltipSpecies: "Species",
                tooltipAge: "Age",
                tooltipSize: "Size",
                maSuffix: " Ma"
            },
            ja: {
                title: "脳容量の進化",
                citation: "データソース: brain-size-list_2.csv | 可視化: D3.js v7",
                stats: "{n} 個の標本をロードしました",
                play: "開始",
                pause: "停止",
                reset: "リセット",
                time: "時間",
                legacy: "レガシースケーリング",
                ageAxis: "年代 (万年前)",
                sizeAxis: "脳容量 (cc)",
                legendTitle: "脳容量 (cc)",
                tooltipName: "名前",
                tooltipSpecies: "種名",
                tooltipAge: "年代",
                tooltipSize: "容量",
                maSuffix: " 万年前"
            }
        };

        // Configuration
        const config = {
            transitionDuration: 300,
            playSpeed: 50, // ms per tick
            defaultStepSize: 2,   // internal ticks per step
            baseRadius: 5,
            baseStroke: 0.5,
            highlightRadiusMultiplier: 2
        };

        // State
        let state = {
            data: [],
            currentTime: 1000,
            isPlaying: false,
            timer: null,
            useLegacyScaling: false,
            lang: 'en'
        };

        // Timeline Events (Major Hominid Milestones)
        const timelineEvents = [
            { age: 7.0, label: "Sahelanthropus" },
            { age: 5.6, label: "Ardipithecus" }, // Approximate range start
            { age: 4.2, label: "Australopithecus" },
            { age: 2.8, label: "Homo habilis" },
            { age: 1.9, label: "Homo erectus" },
            { age: 0.6, label: "H. heidelbergensis" },
            { age: 0.3, label: "Homo sapiens" }
        ];

        // Interval Data (Stacked Bars)
        const intervalData = [
            { start: 2.9, end: 1.7, label: 'Oldowan Tools', row: 0 },
            { start: 2.0, end: 0, label: 'Fire', row: 1 },
            { start: 1.95, end: 0.2, label: 'Acheulean Tools', row: 2 },
            { start: 0.4, end: 0.04, label: 'Levallois Technique', row: 3 },
            { start: 0.16, end: 0.04, label: 'Mousterian Tools', row: 4 },
            { start: 0.05, end: 0, label: 'Modern Behavior', row: 5 },
            { start: 0.02, end: 0, label: 'Ceramics/Textiles/Dogs', row: 6 },
            { start: 0.011, end: 0, label: 'Agriculture', row: 7 }
        ];

        // Singular Milestone Data (Migrations)
        const milestoneData = [
            { age: 1.8, label: "Out of Africa I" },
            { age: 0.065, label: "Into Australia" },
            { age: 0.045, label: "Into Arctic" },
            { age: 0.015, label: "Into Americas" },
            { age: 0.0002, label: "Into Antarctica" }
        ];

        // Reference Data (Horizontal Lines)
        const referenceData = [
            { value: 900, label: "Modern Human (Min)" },
            { value: 1700, label: "Modern Human (Max)" },
            { value: 380, label: "Avg Chimpanzee" }
        ];

        // DOM Elements
        const slider = document.getElementById('time-slider');
        const timelineProgress = document.getElementById('timeline-progress');
        const timelineThumb = document.getElementById('timeline-thumb');
        const markersContainer = document.getElementById('markers-container');
        const timeDisplay = document.getElementById('time-display');
        const playBtn = document.getElementById('play-pause-btn');
        const startBtn = document.getElementById('start-btn');
        const endBtn = document.getElementById('end-btn');
        const langBtn = document.getElementById('lang-btn');
        const scalingToggle = document.getElementById('scaling-toggle');
        const tooltip = document.getElementById('tooltip');
        const mapContainer = document.getElementById('map-container');
        const graphContainer = document.getElementById('graph-container');

        const toggleMapBtn = document.getElementById('toggle-map-btn');
        const toggleGraphBtn = document.getElementById('toggle-graph-btn');

        // Text Elements
        const titleText = document.getElementById('title-text');
        const citationText = document.getElementById('citation-text');
        const statsDisplay = document.getElementById('stats-display');
        const timeLabel = document.getElementById('time-label');
        const legacyLabel = document.getElementById('legacy-label');


        // Main Initialization
        Promise.all([
            d3.json('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-50m.json'),
            d3.csv('brain-size-list_2.csv', d3.autoType)
        ]).then(([worldData, csvData]) => {
            // Process Data
            const cleanData = csvData.map(d => ({
                id: d.ID,
                species: d.Species,
                name: d.Name,
                age: +d.Age,
                cc: +d.CC,
                lat: +d.Lat,
                long: +d.Long
            })).filter(d => d.age != null && d.cc != null && d.lat != null && d.long != null);

            state.data = cleanData;
            updateStatsText();

            // Initial Draw
            initVis(worldData, cleanData);

            // Render Timeline Markers
            renderTimelineMarkers();

            // Event Listeners
            // Slider Input: Value 0 (Past, 10Ma) -> 1000 (Present, 0Ma)
            slider.addEventListener('input', (e) => {
                const sliderVal = +e.target.value;
                state.currentTime = sliderVal;
                updateTimeDisplay();
                updateVis();
                updateSliderVisuals();
            });

            playBtn.addEventListener('click', togglePlay);

            startBtn.addEventListener('click', () => {
                state.currentTime = 0;
                slider.value = 0;
                updateTimeDisplay();
                updateVis();
                updateSliderVisuals();
                clearHighlights();
            });

            endBtn.addEventListener('click', () => {
                state.currentTime = 1000;
                slider.value = 1000;
                updateTimeDisplay();
                updateVis();
                updateSliderVisuals();
                clearHighlights();
            });

            scalingToggle.addEventListener('change', (e) => {
                state.useLegacyScaling = e.target.checked;
                graphVis.updateScale(state.useLegacyScaling);
                updateVis();
                updateTimeDisplay();
            });

            langBtn.addEventListener('click', toggleLanguage);

            toggleMapBtn.addEventListener('click', () => {
                mapContainer.classList.toggle('hidden');
                const isHidden = mapContainer.classList.contains('hidden');
                toggleMapBtn.textContent = isHidden ? "Show Map" : "Hide Map";

                // Force Resize for D3
                setTimeout(() => window.dispatchEvent(new Event('resize')), 300);
            });

            toggleGraphBtn.addEventListener('click', () => {
                graphContainer.classList.toggle('hidden');
                const isHidden = graphContainer.classList.contains('hidden');
                toggleGraphBtn.textContent = isHidden ? "Show Graph" : "Hide Graph";

                // Force Resize for D3
                setTimeout(() => window.dispatchEvent(new Event('resize')), 300);
            });
        });

        // Visualization Instances
        let mapVis, graphVis;

        function initVis(worldData, data) {
            mapVis = new MapVis(mapContainer, worldData, data);
            graphVis = new GraphVis(graphContainer, data);

            // Initial Update
            // Start at 0 Ma (Present) or 10 Ma (Past)?
            // New Logic: Slider 0 = 10Ma. Slider 1000 = 0Ma.
            // Let's start at the beginning of the "movie": 10Ma (Slider 0).
            slider.value = 0;
            state.currentTime = 0;

            updateTimeDisplay();
            updateVis();
            updateSliderVisuals();
        }

        function updateSliderVisuals() {
            const val = +slider.value;
            const max = +slider.max;
            const percent = (val / max) * 100;

            timelineProgress.style.width = `${percent}%`;
            timelineThumb.style.left = `${percent}%`;
        }

        function renderTimelineMarkers() {
            markersContainer.innerHTML = '';
            // Store markers for hover check
            state.markers = [];

            timelineEvents.forEach(evt => {
                const sliderVal = (10 - evt.age) * 100;
                const percent = (sliderVal / 1000) * 100;

                if (percent >= 0 && percent <= 100) {
                    const marker = document.createElement('div');
                    marker.className = 'event-marker';
                    marker.style.left = `${percent}%`;
                    marker.dataset.label = evt.label;
                    marker.dataset.percent = percent; // Store for easy access

                    // No click listener needed: Input handles the click.
                    // Pointer events are none via CSS.

                    markersContainer.appendChild(marker);

                    state.markers.push({
                        element: marker,
                        percent: percent
                    });
                }
            });
        }

        // Setup Hover Logic for Markers
        const trackContainer = document.getElementById('timeline-track-container');
        trackContainer.addEventListener('mousemove', (e) => {
            const rect = trackContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const width = rect.width;
            const percent = (x / width) * 100;

            // Threshold for showing tooltip (e.g. within 1-2%)
            const contentWidth = 1000; // rough px width, or use percentage tolerance
            const tolerance = 1.5; // percent

            state.markers.forEach(m => {
                if (Math.abs(m.percent - percent) < tolerance) {
                    m.element.classList.add('active-hover');
                } else {
                    m.element.classList.remove('active-hover');
                }
            });
        });

        trackContainer.addEventListener('mouseleave', () => {
            if (state.markers) {
                state.markers.forEach(m => m.element.classList.remove('active-hover'));
            }
        });

        function updateVis() {
            // Slider Val: 0 (10Ma) -> 1000 (0Ma)
            // Vis expects: likely just the raw slider val to filter?
            // Existing MapVis update logic:
            // const currentAge = sliderVal / 100; (Previously slider=1000 => 10Ma)

            // New Logic needed for Vis update:
            // We want to pass the "Current Cutoff Age" to the Vis.
            // But MapVis logic was: `const visibleData = data.filter(d => d.age >= currentAge);`
            // If slider was 1000 (10Ma), `currentAge` = 10. `age >= 10` -> Very Few.
            // If slider was 0 (0Ma), `currentAge` = 0. `age >= 0` -> All.

            // New Slider: 0 -> 10Ma (Start). 1000 -> 0Ma (End).
            // We need to calculate `currentAge` from `state.currentTime` (which is 0..1000 now reversed).

            // New Logic: 
            // Slider 0 => Age 10.
            // Slider 1000 => Age 0.
            // Age = 10 - (state.currentTime / 100).

            // MapVis currently expects `sliderVal` and divides by 100 inside `update`.
            // Let's FIX MapVis logic later or adjust what we pass here.
            // Actually, I should probably adjust `updateVis` to calculate Age here and pass Age to the classes.
            // But the classes have `update(data, sliderVal)` so let's stick to passing a number.

            // If I change MapVis to use standard Age, that's better.
            // Let's calc Age here.
            const age = 10 - (state.currentTime / 100);

            // Wait, existing MapVis: `const currentAge = sliderVal / 100;`
            // So if I pass `age * 100`, inside it divides by 100 and gets `age`.
            // Example: Real Age 10. Pass 1000. Inside 1000/100 = 10. Correct.
            // Example: Real Age 0. Pass 0. Inside 0/100 = 0. Correct.

            // So I should pass `age * 100`.
            mapVis.update(state.data, age * 100);
            graphVis.update(state.data, age * 100);
        }

        function highlightSpecimen(id) {
            mapVis.highlight(id);
            graphVis.highlight(id);
        }

        function clearHighlights() {
            mapVis.highlight(null);
            graphVis.highlight(null);
        }

        function updateTimeDisplay() {
            // state.currentTime is 0..1000 (Left to Right)
            // Age = 10 - (state.currentTime / 100)
            const age = 10 - (state.currentTime / 100);

            if (state.useLegacyScaling && state.lang === 'en') {
                // Kiloyears (ka)
                const ageKa = age * 1000;
                timeDisplay.textContent = `${Math.round(ageKa)} ka`;
                return;
            }

            const suffix = i18n[state.lang].maSuffix;

            if (state.lang === 'ja') {
                // 10 Ma = 1000 (Ten Thousands)
                // age * 100 = "Ten Thousands" ? 
                // 1 Ma = 100 Man
                // age comes in Ma (e.g. 5.5).
                // 5.5 Ma = 550 Man
                // So age * 100.
                const val = Math.round(age * 100);
                timeDisplay.textContent = `${val}${suffix}`;
            } else {
                timeDisplay.textContent = `${age.toFixed(2)}${suffix}`;
            }
        }

        function updateStatsText() {
            let text = i18n[state.lang].stats.replace('{n}', state.data.length);
            statsDisplay.innerText = text;
        }

        // Language Toggle Logic
        function toggleLanguage() {
            state.lang = state.lang === 'en' ? 'ja' : 'en';

            // Update static strings
            const t = i18n[state.lang];
            titleText.textContent = t.title;
            citationText.textContent = t.citation;

            updateStatsText();

            playBtn.textContent = state.isPlaying ? t.pause : t.play;

            timeLabel.textContent = t.time + ":";
            legacyLabel.textContent = t.legacy;

            updateTimeDisplay();

            // Trigger Visual Updates for Labels
            mapVis.updateLanguage();
            graphVis.updateLanguage();
        }

        // Legacy Speed Logic (Inverted now?)
        // Originally: Higher value (older) -> Faster/Slower steps?
        // Let's keep it simple or invert it properly.
        // Original: `getLegacyStep(value)` where value was 0..1000 (0=Present, 1000=Past)
        // Now value is 0..1000 (0=Past, 1000=Present).
        // If we want "Slower near present", that corresponds to HIGHER slider values now.
        // Original logic: `if (value <= 1) return 0.02` (Near Present -> Slow).

        // So now, if slider is near 1000 (Present), we want SMALL steps.
        // If slider is near 0 (Past), we can have LARGE steps.

        // We can just map `1000 - sliderVal` to the old function input.

        function getLegacyStep(sliderVal) {
            // Invert sliderVal to get "Time Remaining to Present" sort of index
            // Old val: 0 (Present). New val: 1000 (Present).
            // distToPresent = 1000 - sliderVal.
            // But wait, the old function used scaling on the value itself (0..1000).
            // Let's just use "Age * 100" as the input to the old logic?
            // Old Logic: `if (value <= 1)`. Value was Age*100.
            // So yes, let's use Age*100.

            const ageIndex = (10 - (sliderVal / 100)) * 100; // This gives 0..1000 where 0 is Present.

            // Reuse the exact logic values
            if (ageIndex <= 1) { return 0.02 }
            else if (ageIndex <= 1.6) { return 0.04 }
            else if (ageIndex <= 3) { return 0.06 }
            else if (ageIndex <= 6) { return 0.1 }
            else if (ageIndex <= 12) { return 0.2 }
            else if (ageIndex <= 30) { return 0.5 }
            else if (ageIndex <= 65) { return 0.7 }
            else if (ageIndex <= 120) { return 1 }
            else if (ageIndex <= 250) { return 2 }
            else if (ageIndex <= 400) { return 10 }
            else if (ageIndex <= 1000) { return 20 }
            return config.defaultStepSize;
        }

        function togglePlay() {
            state.isPlaying = !state.isPlaying;
            const t = i18n[state.lang];
            playBtn.textContent = state.isPlaying ? t.pause : t.play;

            if (state.isPlaying) {
                state.timer = setInterval(() => {
                    let step = config.defaultStepSize;

                    if (state.useLegacyScaling) {
                        step = getLegacyStep(state.currentTime);
                    }

                    // Move Slider FORWARD (increase value)
                    let newVal = +slider.value + step;

                    if (newVal > 1000) {
                        newVal = 1000;
                        togglePlay(); // Stop at end
                    }

                    slider.value = newVal;
                    state.currentTime = newVal;
                    updateTimeDisplay();
                    updateVis();
                    updateSliderVisuals();
                }, config.playSpeed);
            } else {
                clearInterval(state.timer);
            }
        }

        // Helper for Tooltip
        function showTooltip(event, d) {
            const t = i18n[state.lang];
            tooltip.style.display = 'block';
            tooltip.innerHTML = `
                 <div class="tooltip-row"><span class="tooltip-label">${t.tooltipName}:</span> ${d.name}</div>
                 <div class="tooltip-row"><span class="tooltip-label">${t.tooltipSpecies}:</span> <i>${d.species}</i></div>
                 <div class="tooltip-row"><span class="tooltip-label">${t.tooltipAge}:</span> ${d.age} Ma</div>
                 <div class="tooltip-row"><span class="tooltip-label">${t.tooltipSize}:</span> ${d.cc} cc</div>
             `;
            // Ensure tooltip stays on screen
            const tooltipRect = tooltip.getBoundingClientRect();
            let left = event.pageX + 10;
            let top = event.pageY + 10;

            if (left + tooltipRect.width > window.innerWidth) {
                left = event.pageX - tooltipRect.width - 10;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        // --- VISUALIZATION CLASSES ---

        class MapVis {
            constructor(container, worldData, allData) {
                this.container = container;
                this.worldData = worldData;
                this.width = container.getBoundingClientRect().width;
                this.height = container.getBoundingClientRect().height;
                this.currentZoom = 1; // Track zoom level

                this.svg = d3.select(container).append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%')
                    .attr('viewBox', `0 0 ${this.width} ${this.height}`)
                    .on('click', (e) => {
                        if (e.target.tagName !== 'circle') {
                            clearHighlights();
                        }
                    });

                // Add Zoom Behavior
                const zoom = d3.zoom()
                    .scaleExtent([1, 8]) // 1x to 8x zoom
                    .on('zoom', (event) => {
                        this.currentZoom = event.transform.k;
                        this.mapGroup.attr('transform', event.transform);

                        // Keep dots same visual size
                        this.pointsGroup.selectAll('circle')
                            .attr('r', d => (d.highlighted ? config.baseRadius * config.highlightRadiusMultiplier : config.baseRadius) / this.currentZoom)
                            .attr('stroke-width', d => (d.highlighted ? 2 : config.baseStroke) / this.currentZoom);

                        this.mapGroup.selectAll('.country')
                            .attr('stroke-width', 0.5 / this.currentZoom);

                        this.mapGroup.selectAll('.graticule')
                            .attr('stroke-width', 0.5 / this.currentZoom);
                    });

                this.svg.call(zoom);

                // Create a group for map content that will be zoomed
                this.mapGroup = this.svg.append('g');

                // Projection
                this.projection = d3.geoEquirectangular()
                    .translate([this.width / 2, this.height / 2])
                    .scale(this.width / 6.5)
                    .rotate([-10, 0]);

                this.path = d3.geoPath().projection(this.projection);

                this.colorScale = d3.scaleSequential(d3.interpolateRdBu)
                    .domain([300, 1600]);

                this.initMap();
                this.renderLegend();

                window.addEventListener('resize', () => {
                    this.width = container.getBoundingClientRect().width;
                    this.height = container.getBoundingClientRect().height;
                    // Reset zoom on resize might be better, or just update projection
                    this.projection.translate([this.width / 2, this.height / 2]).scale(this.width / 6.5);
                    this.mapGroup.selectAll('path').attr('d', this.path); // Update countries/grat lines
                    this.update(state.data, state.currentTime);
                });
            }

            initMap() {
                const countries = topojson.feature(this.worldData, this.worldData.objects.countries);

                // Graticules
                this.mapGroup.append('path')
                    .datum(d3.geoGraticule())
                    .attr('class', 'graticule')
                    .attr('d', this.path);

                // Land
                this.mapGroup.append('g')
                    .selectAll('path')
                    .data(countries.features)
                    .enter().append('path')
                    .attr('class', 'country')
                    .attr('d', this.path);

                // Points Container
                this.pointsGroup = this.mapGroup.append('g');
            }

            renderLegend() {
                // Legend is static in the corner, outside the Zoom Group
                const legendWidth = 200;
                const legendHeight = 10;

                // Remove existing if needed
                d3.select("#map-legend").selectAll("*").remove();

                const defs = this.svg.append("defs"); // Defs in SVG

                const linearGradient = defs.append("linearGradient")
                    .attr("id", "linear-gradient");

                linearGradient.selectAll("stop")
                    .data(d3.ticks(0, 1, 10))
                    .enter().append("stop")
                    .attr("offset", d => d * 100 + "%")
                    .attr("stop-color", d => this.colorScale(300 + d * (1600 - 300)));

                const legend = d3.select("#map-legend");
                this.legendTitle = legend.append("div").style("margin-bottom", "5px").style("font-weight", "bold");
                this.updateLegendTitle();

                const legendSvg = legend.append("svg")
                    .attr("width", legendWidth + 20)
                    .attr("height", 30);

                legendSvg.append("rect")
                    .attr("width", legendWidth)
                    .attr("height", legendHeight)
                    .style("fill", "url(#linear-gradient)");

                const legendScale = d3.scaleLinear()
                    .domain([300, 1600])
                    .range([0, legendWidth]);

                const legendAxis = d3.axisBottom(legendScale).ticks(5).tickSize(5);

                legendSvg.append("g")
                    .attr("transform", `translate(0, ${legendHeight})`)
                    .call(legendAxis);
            }

            updateLegendTitle() {
                this.legendTitle.text(i18n[state.lang].legendTitle);
            }

            updateLanguage() {
                this.updateLegendTitle();
            }

            update(data, sliderVal) {
                const currentAge = sliderVal / 100;
                const visibleData = data.filter(d => d.age >= currentAge);

                const circles = this.pointsGroup.selectAll('circle')
                    .data(visibleData, d => d.id);

                circles.enter()
                    .append('circle')
                    .attr('class', 'data-point')
                    .attr('cx', d => this.projection([d.long, d.lat])[0])
                    .attr('cy', d => this.projection([d.long, d.lat])[1])
                    .attr('r', 0)
                    .attr('fill', d => this.colorScale(d.cc))
                    .attr('fill-opacity', 0.8)
                    .attr('stroke', '#fff')
                    .attr('stroke-width', config.baseStroke / this.currentZoom)
                    .on('mouseover', (event, d) => {
                        showTooltip(event, d);
                        if (!d.highlighted) {
                            d3.select(event.target).attr('stroke', '#000').attr('stroke-width', 2 / this.currentZoom);
                        }
                    })
                    .on('mouseout', (event, d) => {
                        tooltip.style.display = 'none';
                        if (!d.highlighted) {
                            d3.select(event.target).attr('stroke', '#fff').attr('stroke-width', config.baseStroke / this.currentZoom);
                        }
                    })
                    .on('click', (event, d) => {
                        event.stopPropagation();
                        highlightSpecimen(d.id);
                    })
                    .transition().duration(config.transitionDuration)
                    .attr('r', d => (d.highlighted ? config.baseRadius * config.highlightRadiusMultiplier : config.baseRadius) / this.currentZoom);

                circles
                    .attr('cx', d => this.projection([d.long, d.lat])[0])
                    .attr('cy', d => this.projection([d.long, d.lat])[1])
                    .attr('r', d => (d.highlighted ? config.baseRadius * config.highlightRadiusMultiplier : config.baseRadius) / this.currentZoom)
                    .attr('stroke-width', d => (d.highlighted ? 2 : config.baseStroke) / this.currentZoom);

                circles.exit()
                    .transition().duration(config.transitionDuration)
                    .attr('r', 0)
                    .remove();
            }

            highlight(id) {
                if (id === null) {
                    this.pointsGroup.selectAll('circle')
                        .each(function (d) { d.highlighted = false; })
                        .classed('highlighted-point', false)
                        .attr('r', config.baseRadius / this.currentZoom)
                        .attr('stroke', '#fff')
                        .attr('fill', d => this.colorScale(d.cc))
                        .attr('stroke-width', config.baseStroke / this.currentZoom);
                    return;
                }

                this.pointsGroup.selectAll('circle')
                    .each(function (d) {
                        d.highlighted = (d.id === id);
                    })
                    .classed('highlighted-point', d => d.highlighted)
                    .attr('r', d => (d.highlighted ? config.baseRadius * config.highlightRadiusMultiplier : config.baseRadius) / this.currentZoom)
                    .attr('stroke', d => d.highlighted ? '#d00' : '#fff')
                    .attr('fill', d => d.highlighted ? '#ff0000' : this.colorScale(d.cc))
                    .attr('stroke-width', d => (d.highlighted ? 2 : config.baseStroke) / this.currentZoom);
            }
        }

        class GraphVis {
            constructor(container, allData) {
                this.container = container;
                this.width = container.getBoundingClientRect().width;
                this.height = container.getBoundingClientRect().height;
                // Increased top margin for intervals
                this.margin = { top: 160, right: 30, bottom: 40, left: 60 };

                this.svg = d3.select(container).append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%')
                    .on('click', (e) => {
                        if (e.target.tagName !== 'circle') {
                            clearHighlights();
                        }
                    })
                    .on('mousemove', (e) => {
                        this.updateGuides(e);
                    })
                    .on('mouseout', () => {
                        this.hideGuides();
                    });

                this.innerWidth = this.width - this.margin.left - this.margin.right;
                this.innerHeight = this.height - this.margin.top - this.margin.bottom;

                this.chartGroup = this.svg.append('g')
                    .attr('transform', `translate(${this.margin.left},${this.margin.top})`);

                this.yScale = d3.scaleLinear()
                    .domain([0, 1800])
                    .range([this.innerHeight, 0]);

                this.colorScale = d3.scaleSequential(d3.interpolateRdBu)
                    .domain([300, 1600]);

                this.initGraph(allData);

                window.addEventListener('resize', () => {
                    this.width = container.getBoundingClientRect().width;
                    this.height = container.getBoundingClientRect().height;
                    this.innerWidth = this.width - this.margin.left - this.margin.right;
                    this.innerHeight = this.height - this.margin.top - this.margin.bottom;

                    this.yScale.range([this.innerHeight, 0]);
                    this.updateScale(state.useLegacyScaling, false);

                    this.svg.selectAll('*').remove();
                    this.chartGroup = this.svg.append('g').attr('transform', `translate(${this.margin.left},${this.margin.top})`);
                    this.drawAxes();
                    this.drawGuides();
                    this.drawReferenceLines();
                    this.drawBackgroundDots(state.data);
                    this.drawIntervals(); // Draw intervals on redraw
                    this.drawMilestones();

                    // Fix: Calculate correct age for update
                    const age = 10 - (state.currentTime / 100);
                    this.update(state.data, age * 100);
                });
            }

            updateScale(isLegacy, redraw = true) {
                if (isLegacy) {
                    this.xScale = d3.scalePow()
                        .exponent(0.3)
                        .domain([10, 0])
                        .range([0, this.innerWidth]);
                } else {
                    this.xScale = d3.scaleLinear()
                        .domain([10, 0])
                        .range([0, this.innerWidth]);
                }

                if (redraw) {
                    this.svg.selectAll('*').remove();
                    this.chartGroup = this.svg.append('g').attr('transform', `translate(${this.margin.left},${this.margin.top})`);
                    this.drawAxes();
                    this.drawGuides();
                    this.drawReferenceLines();
                    this.drawBackgroundDots(state.data);
                    this.drawIntervals(); // Draw intervals
                    this.drawMilestones();
                    const age = 10 - (state.currentTime / 100);
                    this.update(state.data, age * 100);
                }
            }

            initGraph(data) {
                this.updateScale(false, false);
                this.drawAxes();
                this.drawGuides();
                this.drawReferenceLines();
                this.drawBackgroundDots(data);
                this.drawIntervals(); // Initial draw
                this.drawMilestones();
            }

            drawIntervals() {
                // Interval Bars (Above the chart)
                const barHeight = 14;
                const rowHeight = 18;

                // Group for intervals
                const intervalGroup = this.chartGroup.append('g')
                    .attr('class', 'interval-group');

                intervalData.forEach(d => {
                    // Logic: width = xScale(end) - xScale(start). 
                    // Note: xScale runs High(10) -> Low(0) for Linear?
                    // Let's check: domain([10, 0]).range([0, wid]).
                    // So 10 is at 0px, 0 is at wid px.
                    // Start (e.g. 2.9) is closer to Left. End (1.7) is closer to Right.
                    // xScale(2.9) < xScale(1.7).

                    const x1 = this.xScale(d.start);
                    const x2 = this.xScale(d.end);

                    const w = Math.abs(x2 - x1);
                    const x = Math.min(x1, x2);

                    const y = -(d.row * rowHeight + 20); // Move Up

                    // Bar
                    intervalGroup.append('rect')
                        .attr('x', x)
                        .attr('y', y - barHeight) // y is bottom of text roughly
                        .attr('width', w)
                        .attr('height', barHeight)
                        .attr('fill', '#e0e0e0')
                        .attr('rx', 2);

                    // Text
                    let labelText = `${d.label} (${d.start} Ma)`;
                    if (state.useLegacyScaling && state.lang === 'en') {
                        labelText = `${d.label} (${Math.round(d.start * 1000)} ka)`;
                    }

                    intervalGroup.append('text')
                        .attr('x', x + 4)
                        .attr('y', y - 3)
                        .text(labelText)
                        .attr('font-size', '10px')
                        .attr('fill', '#444')
                        .style('pointer-events', 'none'); // Let click pass through
                });
            }

            drawMilestones() {
                const group = this.chartGroup.append('g').attr('class', 'milestone-group');

                milestoneData.forEach(d => {
                    const x = this.xScale(d.age);

                    // Vertical Line
                    group.append('line')
                        .attr('x1', x)
                        .attr('x2', x)
                        .attr('y1', -10)
                        .attr('y2', this.innerHeight)
                        .attr('stroke', '#666')
                        .attr('stroke-width', 1)
                        .attr('stroke-dasharray', '2 2')
                        .attr('opacity', 0.5)
                        .style('pointer-events', 'none');

                    // Label
                    let labelText = `${d.label} (${d.age} Ma)`;
                    if (state.useLegacyScaling && state.lang === 'en') {
                        labelText = `${d.label} (${Math.round(d.age * 1000)} ka)`;
                    }

                    group.append('text')
                        .attr('x', x)
                        .attr('y', -5)
                        .text(labelText)
                        .attr('font-size', '10px')
                        .attr('fill', '#333')
                        .attr('text-anchor', 'start')
                        .attr('transform', `rotate(-45, ${x}, -5)`)
                        .style('pointer-events', 'none');
                });
            }

            drawReferenceLines() {
                const group = this.chartGroup.append('g').attr('class', 'reference-group');

                referenceData.forEach(d => {
                    const y = this.yScale(d.value);

                    // Horizontal Line
                    group.append('line')
                        .attr('x1', 0)
                        .attr('x2', this.innerWidth)
                        .attr('y1', y)
                        .attr('y2', y)
                        .attr('stroke', '#aaa')
                        .attr('stroke-width', 1)
                        .attr('stroke-dasharray', '2 1')
                        .attr('opacity', 0.6)
                        .style('pointer-events', 'none');

                    // Label
                    group.append('text')
                        .attr('x', this.innerWidth - 5)
                        .attr('y', y - 3)
                        .text(`${d.label} (${d.value}cc)`)
                        .attr('font-size', '9px')
                        .attr('fill', '#666')
                        .attr('text-anchor', 'end')
                        .style('pointer-events', 'none');
                });
            }

            drawAxes() {
                let xAxis;

                if (state.useLegacyScaling) {
                    xAxis = d3.axisBottom(this.xScale)
                        .tickValues([10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0])
                        .tickFormat(d => {
                            // If English and Legacy: use ka (multiply by 1000)
                            if (state.lang === 'en') return d * 1000;
                            return d3.format(".1~f")(d);
                        });
                } else {
                    xAxis = d3.axisBottom(this.xScale);
                }

                const yAxis = d3.axisLeft(this.yScale);
                const t = i18n[state.lang];

                this.chartGroup.append('g')
                    .attr('class', 'axis x-axis')
                    .attr('transform', `translate(0,${this.innerHeight})`)
                    .call(xAxis);

                this.xAxisLabel = this.chartGroup.append('text')
                    .attr('class', 'axis-label')
                    .attr('x', this.innerWidth / 2)
                    .attr('y', this.innerHeight + 30)
                    .style('text-anchor', 'middle')
                    .text(state.useLegacyScaling && state.lang === 'en' ? "Age (ka)" : t.ageAxis);

                this.chartGroup.append('g')
                    .attr('class', 'axis y-axis')
                    .call(yAxis);

                this.yAxisLabel = this.chartGroup.append('text')
                    .attr('class', 'axis-label')
                    .attr('transform', 'rotate(-90)')
                    .attr('x', -this.innerHeight / 2)
                    .attr('y', -45)
                    .style('text-anchor', 'middle')
                    .text(t.sizeAxis);

                // Time Line Group
                this.timeLineGroup = this.chartGroup.append('g')
                    .style('display', 'none')
                    .style('cursor', 'ew-resize');

                // Visible Line
                this.timeLine = this.timeLineGroup.append('line')
                    .attr('class', 'timewindow-line')
                    .attr('y1', 0)
                    .attr('y2', this.innerHeight);

                // Invisible Wider Hit Area
                this.timeLineHit = this.timeLineGroup.append('line')
                    .attr('y1', 0)
                    .attr('y2', this.innerHeight)
                    .attr('stroke', 'transparent')
                    .attr('stroke-width', 20);

                // Drag Behavior
                const drag = d3.drag()
                    .on('drag', (event) => {
                        // event.x is local coordinate in chartGroup
                        const x = Math.max(0, Math.min(this.innerWidth, event.x));
                        const age = this.xScale.invert(x);

                        // Convert Age to Slider Value (0..1000)
                        // Age = 10 - (sliderVal / 100)
                        // sliderVal/100 = 10 - Age
                        // sliderVal = (10 - Age) * 100
                        let sliderVal = (10 - age) * 100;
                        sliderVal = Math.max(0, Math.min(1000, sliderVal));

                        // Update State & UI
                        state.currentTime = sliderVal;
                        slider.value = sliderVal;
                        updateTimeDisplay();
                        updateVis();
                        updateSliderVisuals();
                    });

                this.timeLineGroup.call(drag);
            }

            drawGuides() {
                // Crosshairs
                this.guideX = this.chartGroup.append('line')
                    .attr('stroke', '#999')
                    .attr('stroke-width', 1)
                    .attr('stroke-dasharray', '4 4')
                    .style('display', 'none');

                this.guideY = this.chartGroup.append('line')
                    .attr('stroke', '#999')
                    .attr('stroke-width', 1)
                    .attr('stroke-dasharray', '4 4')
                    .style('display', 'none');

                // Cursor Label
                this.guideLabel = this.chartGroup.append('text')
                    .attr('class', 'guide-label')
                    .attr('fill', '#333')
                    .attr('font-size', '12px')
                    .style('pointer-events', 'none')
                    .style('display', 'none');
            }

            hideGuides() {
                if (this.guideX) this.guideX.style('display', 'none');
                if (this.guideY) this.guideY.style('display', 'none');
                if (this.guideLabel) this.guideLabel.style('display', 'none');
            }

            updateGuides(event) {
                if (!this.guideX || !this.guideY) return;

                // Get mouse position relative to chartGroup
                const [x, y] = d3.pointer(event, this.chartGroup.node());

                // Check if within bounds
                if (x >= 0 && x <= this.innerWidth && y >= 0 && y <= this.innerHeight) {
                    this.guideX.attr('x1', x).attr('x2', x).attr('y1', 0).attr('y2', this.innerHeight).style('display', 'block');
                    this.guideY.attr('y1', y).attr('y2', y).attr('x1', 0).attr('x2', this.innerWidth).style('display', 'block');

                    // Update Labels
                    const age = this.xScale.invert(x);
                    const cc = this.yScale.invert(y);

                    let timeText = `${age.toFixed(2)} Ma`;
                    if (state.useLegacyScaling && state.lang === 'en') {
                        timeText = `${Math.round(age * 1000)} ka`;
                    }

                    this.guideLabel
                        .attr('x', x + 10)
                        .attr('y', y - 10)
                        .text(`${timeText}, ${Math.round(cc)} cc`)
                        .style('display', 'block');

                    // Keep label on screen
                    const labelWidth = this.guideLabel.node().getComputedTextLength();
                    if (x + labelWidth + 20 > this.innerWidth) {
                        this.guideLabel.attr('x', x - labelWidth - 10);
                    }
                } else {
                    this.hideGuides();
                }
            }

            hideGuides() {
                if (this.guideX) this.guideX.style('display', 'none');
                if (this.guideY) this.guideY.style('display', 'none');
            }

            updateLanguage() {
                const t = i18n[state.lang];
                if (this.xAxisLabel) this.xAxisLabel.text(t.ageAxis);
                if (this.yAxisLabel) this.yAxisLabel.text(t.sizeAxis);
            }

            drawBackgroundDots(data) {
                this.chartGroup.selectAll('.bg-dot')
                    .data(data)
                    .enter().append('circle')
                    .attr('class', 'bg-dot')
                    .attr('cx', d => this.xScale(d.age))
                    .attr('cy', d => this.yScale(d.cc))
                    .attr('r', 2)
                    .attr('fill', '#eee');
            }

            update(data, sliderVal) {
                const currentAge = sliderVal / 100;
                const visibleData = data.filter(d => d.age >= currentAge);

                const circles = this.chartGroup.selectAll('.active-dot')
                    .data(visibleData, d => d.id);

                circles.enter()
                    .append('circle')
                    .attr('class', 'active-dot')
                    .attr('cx', d => this.xScale(d.age))
                    .attr('cy', d => this.yScale(d.cc))
                    .attr('r', 0)
                    .attr('fill', d => this.colorScale(d.cc))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 0.5)
                    .on('mouseover', (event, d) => {
                        showTooltip(event, d);
                        d3.select(event.target).attr('stroke', '#000').attr('stroke-width', 2);
                    })
                    .on('mouseout', (event) => {
                        tooltip.style.display = 'none';
                        // Only reset if not selected. But how to know? d.selected or just assume class?
                        if (!d3.select(event.target).classed('selected')) {
                            d3.select(event.target).attr('stroke', '#333').attr('stroke-width', 0.5);
                        }
                    })
                    .on('click', (event, d) => {
                        event.stopPropagation();
                        highlightSpecimen(d.id);
                    })
                    .transition().duration(200)
                    .attr('r', 4);

                circles.exit()
                    .transition().duration(200)
                    .attr('r', 0)
                    .remove();

                circles
                    .attr('cx', d => this.xScale(d.age))
                    .attr('cy', d => this.yScale(d.cc));

                if (this.timeLineGroup) {
                    this.timeLineGroup
                        .style('display', 'block')
                        .attr('transform', `translate(${this.xScale(currentAge)}, 0)`);

                    // Lines are drawn at x=0 relative to group, so just ensure their vertical is set (done in init)

                    this.timeLineGroup.raise();
                }
            }

            highlight(id) {
                if (id === null) {
                    this.chartGroup.selectAll('.active-dot')
                        .classed('selected', false)
                        .attr('stroke', '#333')
                        .attr('stroke-width', 0.5)
                        .attr('fill', d => this.colorScale(d.cc))
                        .attr('r', 4);
                    return;
                }

                // Remove highlight from all
                this.chartGroup.selectAll('.active-dot')
                    .classed('selected', false)
                    .attr('stroke', '#333')
                    .attr('stroke-width', 0.5)
                    .attr('fill', d => this.colorScale(d.cc))
                    .attr('r', 4);

                // Add to specific
                const dot = this.chartGroup.selectAll('.active-dot')
                    .filter(d => d.id === id);

                dot.classed('selected', true)
                    .attr('stroke', '#d00')
                    .attr('stroke-width', 2)
                    .attr('fill', '#d00')
                    .transition().duration(200)
                    .attr('r', 8);
            }
        }
    </script>
</body>

</html>