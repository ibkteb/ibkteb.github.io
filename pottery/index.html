<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Early Pottery Sites Worldwide (Canvas)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/proj4@2.9.0/dist/proj4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/proj4leaflet@1.0.2/src/proj4leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #333333;
            --border-color: #cccccc;
            --accent-color: #2c3e50;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 20px;
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        header {
            width: 100%;
            max-width: 1400px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            border-bottom: 2px solid var(--text-color);
            padding-bottom: 10px;
        }

        h1 {
            margin: 0;
            font-size: 24px;
            font-weight: 700;
        }

        .citation {
            font-size: 12px;
            color: #666;
        }

        #controls {
            width: 100%;
            max-width: 1400px;
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 10px;
            background: #f9f9f9;
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
            font-size: 14px;
            flex-wrap: wrap;
        }

        #lang-btn {
            background: none;
            border: 1px solid #999;
            color: #666;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            margin-left: 10px;
        }

        #lang-btn:hover {
            background: #eee;
            color: #333;
        }

        button.control-btn {
            padding: 6px 16px;
            cursor: pointer;
            font-size: 14px;
            background: white;
            border: 1px solid var(--text-color);
            border-radius: 2px;
            transition: background 0.2s;
        }

        button.control-btn:hover {
            background: #eee;
        }

        button.control-btn:active {
            background: #ddd;
        }

        .slider-container {
            display: flex;
            align-items: center;
            flex-grow: 1;
            gap: 15px;
        }

        input[type=range] {
            flex-grow: 1;
            cursor: pointer;
            margin: 0 10px;
        }

        .value-display {
            font-family: "Courier New", monospace;
            font-weight: bold;
            min-width: 120px;
            text-align: right;
        }

        #main-view {
            display: flex;
            flex-direction: row;
            width: 100%;
            max-width: 1400px;
            height: calc(100% - 140px);
            gap: 20px;
        }

        #map-container {
            flex: 1;
            width: 100%;
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        .legend-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border: 1px solid #ccc;
            font-size: 11px;
            pointer-events: none;
            border-radius: 4px;
            z-index: 1000;
        }

        .map-date-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 25px;
            border: 2px solid #333;
            font-size: 48px;
            font-weight: bold;
            font-family: "Courier New", monospace;
            pointer-events: none;
            border-radius: 8px;
            z-index: 1000;
            color: #333;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 1px solid #666;
        }

        .filter-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .filter-group label {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            user-select: none;
        }

        .filter-group input[type="checkbox"] {
            cursor: pointer;
        }

        #canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 400;
        }

        .tooltip {
            position: absolute;
            background: rgba(44, 62, 80, 0.95);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1001;
            white-space: nowrap;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .tooltip.visible {
            opacity: 1;
        }
    </style>
</head>

<body>
    <header>
        <div>
            <h1 id="title-text">Early Pottery Sites Worldwide (Canvas)</h1>
            <div class="citation" id="citation-text">Data source: early pottery sites - list.csv | Visualization:
                Leaflet + Canvas</div>
        </div>
        <div style="text-align: right; font-size: 12px;">
            <span id="stats-display">Loaded 0 sites</span>
            <button id="lang-btn">EN/JA</button>
        </div>
    </header>

    <div id="controls">
        <button id="play-pause-btn" class="control-btn">Play</button>
        <button id="reset-btn" class="control-btn">Reset</button>
        <div class="slider-container">
            <span style="font-weight: bold;" id="time-label">Time:</span>
            <input type="range" id="time-slider" min="0" max="17000" value="17000" step="10">
            <span class="value-display" id="time-display">17,000 BP</span>
        </div>
        <div class="slider-container">
            <span style="font-weight: bold;">Window:</span>
            <input type="range" id="window-slider" min="0" max="5000" value="1000" step="50">
            <span class="value-display" id="window-display">±1,000 years</span>
        </div>
        <div class="filter-group" id="filter-group">
            <span style="font-weight: bold;" id="filter-label">Economy:</span>
            <label><input type="checkbox" id="filter-hg" checked> <span id="filter-hg-label">HG</span></label>
            <label><input type="checkbox" id="filter-f" checked> <span id="filter-f-label">F</span></label>
            <label><input type="checkbox" id="filter-me" checked> <span id="filter-me-label">ME</span></label>
        </div>
        <div class="filter-group">
            <label><input type="checkbox" id="filter-kites"> <span id="filter-kites-label">Desert
                    Kites</span></label>
            <label><input type="checkbox" id="filter-rivers" checked> <span
                    id="filter-rivers-label">Rivers</span></label>
            <label><input type="checkbox" id="filter-lakes" checked> <span id="filter-lakes-label">Lakes</span></label>
        </div>
        <div class="filter-group">
            <label><input type="checkbox" id="filter-trail" checked> <span id="filter-trail-label">Trail</span></label>
            <label><input type="checkbox" id="filter-network" checked> <span id="filter-network-label">Network</span></label>
            <label><input type="checkbox" id="filter-metaballs" checked> <span id="filter-metaballs-label">Metaballs</span></label>
            <label><input type="checkbox" id="filter-precomputed-lines" checked> <span id="filter-precomputed-lines-label">LCP Paths</span></label>
        </div>
    </div>

    <div id="main-view">
        <div id="map-container">
            <div class="legend-container" id="map-legend"></div>
            <div class="map-date-display" id="map-date-display"></div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Localization
        const i18n = {
            en: {
                title: "Early Pottery Sites Worldwide (Canvas)",
                citation: "Data source: early pottery sites - list.csv | Visualization: Leaflet + Canvas",
                stats: "Loaded {n} sites",
                play: "Play",
                pause: "Pause",
                reset: "Reset",
                time: "Time",
                filter: "Economy",
                legendTitle: "Economy Type",
                tooltipName: "Site",
                tooltipAge: "Age",
                tooltipAgeCal: "Cal BP",
                tooltipEconomy: "Economy",
                tooltipLat: "Latitude",
                tooltipLong: "Longitude",
                bpSuffix: " BP",
                economyHG: "Hunter-Gatherer",
                economyF: "Farmer",
                economyME: "Mixed Economy",
                economyOther: "Unknown/Other",
                kites: "Desert Kites",
                rivers: "Rivers",
                lakes: "Lakes"
            },
            ja: {
                title: "世界の初期土器遺跡 (Canvas)",
                citation: "データソース: early pottery sites - list.csv | 可視化: Leaflet + Canvas",
                stats: "{n} 箇所の遺跡をロードしました",
                play: "開始",
                pause: "停止",
                reset: "リセット",
                time: "時間",
                filter: "経済",
                legendTitle: "経済タイプ",
                tooltipName: "遺跡名",
                tooltipAge: "年代",
                tooltipAgeCal: "較正BP",
                tooltipEconomy: "経済",
                tooltipLat: "緯度",
                tooltipLong: "経度",
                bpSuffix: " BP",
                economyHG: "狩猟採集民",
                economyF: "農耕民",
                economyME: "混合経済",
                economyOther: "不明/その他",
                kites: "砂漠の凧",
                rivers: "河川",
                lakes: "湖"
            }
        };

        // Economy color scale
        const economyColors = {
            'HG': { r: 230, g: 80, b: 80 },  // Hunter-Gatherer
            'F': { r: 0, g: 100, b: 110 },    // Farmer
            'ME': { r: 115, g: 60, b: 130 },  // Mixed Economy
            'other': { r: 149, g: 165, b: 166 } // Unknown/Other
        };

        // Configuration
        const config = {
            playSpeed: 50,  // ms between frames during playback
            playStep: 50,   // years to advance per frame
            baseRadius: 6,
            fadeInDuration: 500,  // ms for site to fade in
            fadeOutDuration: 500, // ms for site to fade out
            pulseSpeed: 2000,     // ms for one pulse cycle
            labelDisplayTime: 2000, // ms to show label during playback
            showTrail: true,      // show old faded points
            showNetwork: true,    // show network connections
            showMetaballs: true,  // show metaball visualization
            showPrecomputedLines: true,  // show precomputed network as dotted lines
            metaballRadius: 40,   // radius of influence for metaballs
            metaballThreshold: 0.5, // threshold for metaball field
        };

        // State
        let state = {
            data: [],
            currentTime: 17000,
            timeWindow: 1000,  // Show sites within ±N years
            isPlaying: false,
            playInterval: null,
            lang: 'en',
            filters: {
                HG: true,
                F: true,
                ME: true
            },
            hoveredSite: null,
            lastLabelTime: 0,
            lastLabelSiteId: null
        };

        // DOM Elements
        const slider = document.getElementById('time-slider');
        const windowSlider = document.getElementById('window-slider');
        const timeDisplay = document.getElementById('time-display');
        const windowDisplay = document.getElementById('window-display');
        const playBtn = document.getElementById('play-pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const langBtn = document.getElementById('lang-btn');
        const mapContainer = document.getElementById('map-container');
        const mapDateDisplay = document.getElementById('map-date-display');
        const tooltip = document.getElementById('tooltip');

        // Filter checkboxes
        const filterHG = document.getElementById('filter-hg');
        const filterF = document.getElementById('filter-f');
        const filterME = document.getElementById('filter-me');
        const filterKites = document.getElementById('filter-kites');
        const filterRivers = document.getElementById('filter-rivers');
        const filterLakes = document.getElementById('filter-lakes');
        const filterTrail = document.getElementById('filter-trail');
        const filterNetwork = document.getElementById('filter-network');
        const filterMetaballs = document.getElementById('filter-metaballs');
        const filterPrecomputedLines = document.getElementById('filter-precomputed-lines');

        // Text Elements
        const titleText = document.getElementById('title-text');
        const citationText = document.getElementById('citation-text');
        const statsDisplay = document.getElementById('stats-display');
        const timeLabel = document.getElementById('time-label');
        const filterLabel = document.getElementById('filter-label');

        // Helper to normalize economy types
        function normalizeEconomy(eco) {
            if (!eco) return 'other';
            const e = eco.toString().trim().toUpperCase().replace(/[^A-Z\/]/g, '');
            if (e === 'HG') return 'HG';
            if (e === 'F') return 'F';
            if (e === 'ME' || e.includes('HG') && e.includes('ME') || e === 'F/ME' || e === 'HG/ME') return 'ME';
            if (e.includes('F')) return 'F';
            return 'other';
        }

        // Helper to convert BP to BC/AD
        function bpToBC(bp) {
            const bc = bp - 1950;
            if (bc > 0) {
                return Math.round(bc).toLocaleString() + ' BC';
            } else {
                return Math.round(Math.abs(bc)).toLocaleString() + ' AD';
            }
        }

        // Update map date display
        function updateMapDateDisplay() {
            if (mapDateDisplay) {
                mapDateDisplay.innerHTML = `${bpToBC(state.currentTime)}<br>${Math.round(state.currentTime).toLocaleString()} BP`;
            }
        }

        // Main Initialization
        Promise.all([
            d3.csv('pottery_sites.csv'),
            d3.json('kites.json'),
            d3.json('natural_earth/rivers.geojson'),
            d3.json('natural_earth/lakes.geojson'),
            d3.json('natural_earth/ne_50m_coastline.geojson'),
            d3.json('natural_earth/ne_50m_ocean.geojson'),
            d3.json('precomputed_networks.json') // Required for network rendering
        ]).then(([csvData, kitesData, riversData, lakesData, coastlineData, oceanData, precomputedData]) => {
            // Load pre-computed networks (required)
            if (precomputedData) {
                precomputedNetworks.data = precomputedData;
                precomputedNetworks.snapshots = precomputedData.snapshots || [];
                precomputedNetworks.loaded = true;
                console.log(`Loaded ${precomputedNetworks.snapshots.length} pre-computed network snapshots`);
                console.log('Network metadata:', precomputedData.metadata);
            } else {
                console.error('ERROR: precomputed_networks.json is required. Run: python precompute_networks.py');
            }
            // Process Data
            const cleanData = csvData.map((d, i) => {
                let dateStr = d['date_bp_uncal'] || d['date_bp'] || '';
                let calBP = d['date_bp'] || '';

                let uncalBP = parseInt(dateStr.toString().replace(/[^\d]/g, '').slice(0, 5)) || 0;
                let calibratedBP = parseInt(calBP.toString().replace(/[^\d]/g, '')) || uncalBP;

                return {
                    id: i,
                    name: (d['site'] || '').trim(),
                    lat: parseFloat(d.latitude),
                    long: parseFloat(d.longitude),
                    uncalBP: uncalBP,
                    calBP: calibratedBP,
                    economy: normalizeEconomy(d.economy),
                    retained: d.retained === 'TRUE'
                };
            }).filter(d =>
                d.name &&
                !isNaN(d.lat) &&
                !isNaN(d.long) &&
                d.calBP > 0 &&
                d.lat >= -90 && d.lat <= 90 &&
                d.long >= -180 && d.long <= 180
            );

            state.data = cleanData;
            console.log(cleanData)
            updateStatsText();

            slider.max = 20000;
            slider.value = slider.max;
            state.currentTime = +slider.max;
            updateMapDateDisplay();

            // Initial Draw
            initVis(cleanData, kitesData, riversData, lakesData, coastlineData, oceanData);

            // Event Listeners
            slider.addEventListener('input', (e) => {
                state.currentTime = +e.target.value;
                updateTimeDisplay();
                updateMapDateDisplay();
            });

            windowSlider.addEventListener('input', (e) => {
                state.timeWindow = +e.target.value;
                updateWindowDisplay();
            });

            playBtn.addEventListener('click', togglePlay);
            resetBtn.addEventListener('click', () => {
                if (state.isPlaying) togglePlay();
                state.currentTime = +slider.max;
                slider.value = slider.max;
                updateTimeDisplay();
                updateMapDateDisplay();
            });

            filterHG.addEventListener('change', () => { state.filters.HG = filterHG.checked; });
            filterF.addEventListener('change', () => { state.filters.F = filterF.checked; });
            filterME.addEventListener('change', () => { state.filters.ME = filterME.checked; });

            filterKites.addEventListener('change', (e) => {
                canvasVis.toggleKites(e.target.checked);
            });
            filterRivers.addEventListener('change', (e) => {
                canvasVis.toggleRivers(e.target.checked);
            });
            filterLakes.addEventListener('change', (e) => {
                canvasVis.toggleLakes(e.target.checked);
            });
            filterTrail.addEventListener('change', (e) => {
                config.showTrail = e.target.checked;
            });
            filterNetwork.addEventListener('change', (e) => {
                config.showNetwork = e.target.checked;
            });
            filterMetaballs.addEventListener('change', (e) => {
                config.showMetaballs = e.target.checked;
            });
            filterPrecomputedLines.addEventListener('change', (e) => {
                config.showPrecomputedLines = e.target.checked;
            });

            langBtn.addEventListener('click', toggleLanguage);

            // Mouse interaction for tooltips
            mapContainer.addEventListener('mousemove', handleMouseMove);
            mapContainer.addEventListener('mouseout', handleMouseOut);
        });

        // Visualization Instance
        let canvasVis;

        function initVis(data, kitesData, riversData, lakesData, coastlineData, oceanData) {
            canvasVis = new CanvasMapVis(mapContainer, data, kitesData, riversData, lakesData, coastlineData, oceanData);
            updateTimeDisplay();
            updateWindowDisplay();
        }

        function getFilteredData() {
            return state.data.filter(d => {
                if (d.economy === 'HG' && !state.filters.HG) return false;
                if (d.economy === 'F' && !state.filters.F) return false;
                if ((d.economy === 'ME' || d.economy === 'other') && !state.filters.ME) return false;
                return true;
            });
        }

        function updateTimeDisplay() {
            const val = Math.round(state.currentTime);
            timeDisplay.textContent = val.toLocaleString() + i18n[state.lang].bpSuffix;
        }

        function updateWindowDisplay() {
            windowDisplay.textContent = '±' + state.timeWindow.toLocaleString() + ' years';
        }

        function updateStatsText() {
            let text = i18n[state.lang].stats.replace('{n}', state.data.length);
            statsDisplay.innerText = text;
        }

        function toggleLanguage() {
            state.lang = state.lang === 'en' ? 'ja' : 'en';

            const t = i18n[state.lang];
            titleText.textContent = t.title;
            citationText.textContent = t.citation;

            updateStatsText();

            playBtn.textContent = state.isPlaying ? t.pause : t.play;
            resetBtn.textContent = t.reset;
            timeLabel.textContent = t.time + ":";
            filterLabel.textContent = t.filter + ":";
            document.getElementById('filter-kites-label').textContent = t.kites;
            document.getElementById('filter-rivers-label').textContent = t.rivers;
            document.getElementById('filter-lakes-label').textContent = t.lakes;

            updateTimeDisplay();

            canvasVis.updateLanguage();
        }

        function togglePlay() {
            state.isPlaying = !state.isPlaying;
            const t = i18n[state.lang];
            playBtn.textContent = state.isPlaying ? t.pause : t.play;

            if (state.isPlaying) {
                state.playInterval = setInterval(() => {
                    state.currentTime -= config.playStep;

                    if (state.currentTime < 0) {
                        state.currentTime = 0;
                        togglePlay();
                        return;
                    }

                    slider.value = state.currentTime;
                    updateTimeDisplay();
                    updateMapDateDisplay();

                    // Show label for newly visible sites during playback
                    const now = Date.now();
                    if (now - state.lastLabelTime > config.labelDisplayTime) {
                        const newSites = getFilteredData().filter(d =>
                            d.calBP <= state.currentTime + state.timeWindow &&
                            d.calBP >= state.currentTime - state.timeWindow &&
                            d.id !== state.lastLabelSiteId
                        );

                        if (newSites.length > 0) {
                            // Show label for the oldest (newest to appear) site
                            const newestSite = newSites.reduce((a, b) => a.calBP > b.calBP ? a : b);
                            showLabel(newestSite);
                            state.lastLabelTime = now;
                            state.lastLabelSiteId = newestSite.id;
                        }
                    }
                }, config.playSpeed);
            } else {
                clearInterval(state.playInterval);
                hideLabel();
            }
        }

        function handleMouseMove(e) {
            if (!canvasVis) return;

            const rect = mapContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const site = canvasVis.getSiteAtPosition(x, y);

            if (site) {
                state.hoveredSite = site;
                showTooltip(e.clientX, e.clientY, site);
            } else {
                state.hoveredSite = null;
                hideTooltip();
            }
        }

        function handleMouseOut() {
            state.hoveredSite = null;
            hideTooltip();
        }

        function showTooltip(x, y, site) {
            const t = i18n[state.lang];
            tooltip.innerHTML = `
                <div><strong>${site.name}</strong></div>
                <div>${t.tooltipAgeCal}: ${site.calBP.toLocaleString()} BP</div>
                <div>${t.tooltipEconomy}: ${t['economy' + site.economy.toUpperCase().replace('OTHER', 'Other')]}</div>
            `;
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
            tooltip.classList.add('visible');
        }

        function hideTooltip() {
            tooltip.classList.remove('visible');
        }

        let currentLabelTimeout = null;

        function showLabel(site) {
            if (!canvasVis) return;

            const point = canvasVis.map.latLngToContainerPoint([site.lat, site.long]);
            const rect = mapContainer.getBoundingClientRect();

            tooltip.innerHTML = `<strong>${site.name}</strong>`;
            tooltip.style.left = (rect.left + point.x + 15) + 'px';
            tooltip.style.top = (rect.top + point.y - 30) + 'px';
            tooltip.classList.add('visible');

            if (currentLabelTimeout) {
                clearTimeout(currentLabelTimeout);
            }

            currentLabelTimeout = setTimeout(() => {
                hideLabel();
            }, config.labelDisplayTime);
        }

        function hideLabel() {
            tooltip.classList.remove('visible');
        }

        // --- PRECOMPUTED NETWORK DATA ---

        // Global obstacle data (for visualization only)
        let obstacleData = {
            mountains: null,
            coastlines: null,
            loaded: false
        };

        // Pre-computed networks data
        let precomputedNetworks = {
            data: null,
            loaded: false,
            snapshots: []
        };

        // --- CANVAS VISUALIZATION CLASS ---
        //
        // This visualization is RENDER-ONLY - all network computation is done offline.
        // To generate/update the network data, run: python precompute_networks.py
        //
        // The precomputed_networks.json file contains:
        // - Network edges (minimum spanning tree with terrain avoidance)
        // - Metaball influence points (for smooth visualization)
        // - Metadata about computation settings
        //

        class CanvasMapVis {
            constructor(container, allData, kitesData, riversData, lakesData, coastlineData, oceanData) {
                this.container = container;
                this.allData = allData;
                this.kitesData = kitesData;
                this.riversData = riversData;
                this.lakesData = lakesData;
                this.coastlineData = coastlineData;
                this.oceanData = oceanData;

                this.showKites = false;
                this.showRivers = true;
                this.showLakes = true;

                // Network cache
                this.networkCache = null;
                this.lastCacheParams = null;

                // Initialize Leaflet map
                this.map = L.map(container, {
                    crs: L.CRS.EPSG4326,
                    center: [0, 0],
                    zoom: 2,
                    minZoom: 1,
                    maxZoom: 6
                });

                // Add Natural Earth raster
                const imageBounds = [[-90, -180], [90, 180]];
                // L.imageOverlay('./natural_earth/NE1_HR_LC_SR_W_4326.png', imageBounds, {
                //     attribution: 'Natural Earth',
                // }).addTo(this.map)
                L.imageOverlay('basemaps/world_hillshade_4326.png', imageBounds, {
                    attribution: 'ESRI World Hillshade',
                    opacity: 1.0
                }).addTo(this.map)

                // Add Natural Earth ocean and coastline
                this.oceanLayer = L.geoJSON(oceanData, {
                    style: {
                        color: '#2E5266',
                        weight: 0,
                        fillColor: '#4A90E2',
                        fillOpacity: 0.2
                    }
                }).addTo(this.map);

                this.coastlineLayer = L.geoJSON(coastlineData, {
                    style: {
                        color: '#333333',
                        weight: 1,
                        opacity: 0.5
                    }
                }).addTo(this.map);

                // Add GeoJSON layers
                this.kitesLayer = L.layerGroup();
                if (kitesData && kitesData.features) {
                    kitesData.features.forEach(feature => {
                        const coords = feature.geometry.coordinates;
                        const marker = L.circleMarker([coords[1], coords[0]], {
                            radius: 3,
                            fillColor: '#e74c3c',
                            color: 'none',
                            fillOpacity: 0.6
                        });
                        this.kitesLayer.addLayer(marker);
                    });
                }

                this.riversLayer = L.geoJSON(riversData, {
                    style: {
                        color: '#4A90E2',
                        weight: 1,
                        opacity: 0.6
                    }
                }).addTo(this.map);

                this.lakesLayer = L.geoJSON(lakesData, {
                    style: {
                        color: '#4A90E2',
                        weight: 1,
                        fillColor: '#A8D5F7',
                        fillOpacity: 0.3,
                        opacity: 0.6
                    }
                }).addTo(this.map);

                // Create canvas overlay
                this.canvas = document.createElement('canvas');
                this.canvas.id = 'canvas-overlay';
                this.ctx = this.canvas.getContext('2d');
                this.container.appendChild(this.canvas);

                // Size canvas to match container
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                // Initialize land mask flag
                this.landMaskNeedsUpdate = true;

                // Listen to map events
                this.map.on('move zoom viewreset', () => {
                    this.landMaskNeedsUpdate = true;
                    this.render();
                });

                // Render legend
                this.renderLegend();

                // Start animation loop
                this.startAnimationLoop();
            }

            resizeCanvas() {
                const rect = this.container.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.render();
            }

            toggleKites(show) {
                this.showKites = show;
                if (show) {
                    this.map.addLayer(this.kitesLayer);
                } else {
                    this.map.removeLayer(this.kitesLayer);
                }
            }

            toggleRivers(show) {
                this.showRivers = show;
                if (show) {
                    this.map.addLayer(this.riversLayer);
                } else {
                    this.map.removeLayer(this.riversLayer);
                }
            }

            toggleLakes(show) {
                this.showLakes = show;
                if (show) {
                    this.map.addLayer(this.lakesLayer);
                } else {
                    this.map.removeLayer(this.lakesLayer);
                }
            }

            renderLegend() {
                d3.select("#map-legend").selectAll("*").remove();

                const legend = d3.select("#map-legend");
                this.legendTitle = legend.append("div")
                    .style("margin-bottom", "8px")
                    .style("font-weight", "bold");
                this.updateLegendTitle();

                const t = i18n[state.lang];
                const items = [
                    { key: 'HG', label: t.economyHG, color: economyColors.HG },
                    { key: 'F', label: t.economyF, color: economyColors.F },
                    { key: 'ME', label: t.economyME, color: economyColors.ME },
                    { key: 'other', label: t.economyOther, color: economyColors.other }
                ];

                items.forEach(item => {
                    const div = legend.append("div").attr("class", "legend-item");
                    div.append("div")
                        .attr("class", "legend-color")
                        .style("background-color", `rgb(${item.color.r}, ${item.color.g}, ${item.color.b})`);
                    div.append("span").text(item.label);
                });
            }

            updateLegendTitle() {
                this.legendTitle.text(i18n[state.lang].legendTitle);
            }

            updateLanguage() {
                this.renderLegend();
            }

            startAnimationLoop() {
                const animate = () => {
                    this.render();
                    this.animationFrame = requestAnimationFrame(animate);
                };
                animate();
            }

            getVisibleSites() {
                const filtered = getFilteredData();
                const currentTime = state.currentTime;
                const window = state.timeWindow;

                return filtered.filter(d => {
                    const age = d.calBP;
                    return (age - window) <= currentTime && age >= currentTime;
                }).map(d => {
                    // Calculate animation state
                    const age = d.calBP;
                    const timeSinceAppearance = age - currentTime;
                    const timeUntilDisappearance = currentTime - (age - window);

                    let opacity = 1.0;
                    let radiusMultiplier = 1.0;

                    // Immediate appearance with pulse, then fade out
                    if (timeSinceAppearance < config.fadeInDuration) {
                        // Starts at 1.5 and shrinks smoothly to 1.0
                        const progress = Math.min(1, timeSinceAppearance / config.fadeInDuration);
                        radiusMultiplier = 1.0 + 0.5 * Math.cos(progress * (Math.PI / 2));
                    } else {
                        // After pulse, shrink slightly while fading
                        const shrinkProgress = Math.min(1, (timeSinceAppearance - config.fadeInDuration) / config.fadeOutDuration);
                        radiusMultiplier = 1.0 - 0.3 * shrinkProgress;
                    }

                    // Fade out
                    if (timeUntilDisappearance < config.fadeOutDuration) {
                        opacity = timeUntilDisappearance / config.fadeOutDuration;
                    }

                    // Calculate recency for glow effect
                    const recency = 1 - timeUntilDisappearance / (2 * window);

                    return {
                        ...d,
                        opacity: Math.max(0, Math.min(1, opacity)),
                        radius: config.baseRadius * radiusMultiplier,
                        recency: recency
                    };
                });
            }

            getOldSites() {
                const filtered = getFilteredData();
                const currentTime = state.currentTime;
                const window = state.timeWindow;

                // Sites that are older than current time window
                return filtered.filter(d => d.calBP > currentTime + window);
            }

            computeNetwork(networkPoints, currentTime) {
                // Only use pre-computed networks (no runtime computation)
                if (precomputedNetworks.loaded) {
                    return this.getPrecomputedNetwork(currentTime);
                }

                // Return empty if no precomputed data available
                console.warn('No precomputed network data available');
                return { edges: [], metaballPoints: [] };
            }

            getPrecomputedNetwork(currentTime) {
                // Find closest snapshot by time
                let closestSnapshot = null;
                let minDiff = Infinity;

                for (const snapshot of precomputedNetworks.snapshots) {
                    const diff = Math.abs(snapshot.time - currentTime);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestSnapshot = snapshot;
                    }
                }

                if (!closestSnapshot || !closestSnapshot.edges) {
                    return { edges: [], metaballPoints: [] };
                }

                // Convert pre-computed edges to canvas coordinates
                const edges = closestSnapshot.edges.map(edge => {
                    const p1 = this.map.latLngToContainerPoint([edge.from_lat, edge.from_lng]);
                    const p2 = this.map.latLngToContainerPoint([edge.to_lat, edge.to_lng]);

                    return {
                        p1: { x: p1.x, y: p1.y },
                        p2: { x: p2.x, y: p2.y },
                        dist: edge.cost || 0
                    };
                });

                // Convert precomputed metaball points to canvas coordinates
                let metaballPoints = [];
                if (closestSnapshot.metaball_points) {
                    metaballPoints = closestSnapshot.metaball_points.map(point => {
                        const p = this.map.latLngToContainerPoint([point[0], point[1]]);
                        return { x: p.x, y: p.y };
                    });
                }

                // Store snapshot for use in rendering
                this.currentSnapshot = closestSnapshot;

                return { edges, metaballPoints };
            }

            // Create a land mask from ocean polygons (inverted)
            createLandMask() {
                if (!this.landMaskCanvas) {
                    this.landMaskCanvas = document.createElement('canvas');
                    this.landMaskCtx = this.landMaskCanvas.getContext('2d', { alpha: true, willReadFrequently: false });
                }

                const width = this.canvas.width;
                const height = this.canvas.height;

                // Resize if needed
                if (this.landMaskCanvas.width !== width || this.landMaskCanvas.height !== height) {
                    this.landMaskCanvas.width = width;
                    this.landMaskCanvas.height = height;
                    this.landMaskNeedsUpdate = true;
                }

                // Only regenerate if needed (on resize or map move)
                if (!this.landMaskNeedsUpdate) return;

                const ctx = this.landMaskCtx;
                ctx.clearRect(0, 0, width, height);

                // Fill entire canvas with white (land)
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, width, height);

                // Cut out ocean areas (make them transparent)
                if (this.oceanData && this.oceanData.features) {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.fillStyle = 'black';

                    this.oceanData.features.forEach(feature => {
                        if (feature.geometry.type === 'Polygon') {
                            this.drawPolygonToCanvas(ctx, feature.geometry.coordinates);
                        } else if (feature.geometry.type === 'MultiPolygon') {
                            feature.geometry.coordinates.forEach(polygon => {
                                this.drawPolygonToCanvas(ctx, polygon);
                            });
                        }
                    });

                    ctx.globalCompositeOperation = 'source-over';
                }

                this.landMaskNeedsUpdate = false;
            }

            // Helper to draw GeoJSON polygon to canvas
            drawPolygonToCanvas(ctx, coordinates) {
                coordinates.forEach((ring, ringIndex) => {
                    ctx.beginPath();
                    ring.forEach((coord, i) => {
                        const point = this.map.latLngToContainerPoint([coord[1], coord[0]]);
                        if (i === 0) {
                            ctx.moveTo(point.x, point.y);
                        } else {
                            ctx.lineTo(point.x, point.y);
                        }
                    });
                    ctx.closePath();
                    ctx.fill();
                });
            }

            // Render metaballs using precomputed influence points
            renderMetaballs(edges, precomputedPoints) {
                if (!config.showMetaballs || edges.length === 0) return;

                const ctx = this.ctx;
                const width = this.canvas.width;
                const height = this.canvas.height;

                // Use only precomputed points (no fallback)
                if (!precomputedPoints || precomputedPoints.length === 0) {
                    console.warn('No precomputed metaball points available');
                    return;
                }

                let influencePoints = precomputedPoints;

                // Filter points that are on-screen or near the screen
                const margin = config.metaballRadius * 2;
                influencePoints = influencePoints.filter(p =>
                    p.x >= -margin && p.x <= width + margin &&
                    p.y >= -margin && p.y <= height + margin
                );

                if (influencePoints.length === 0) return;

                // Create a lower resolution field for performance
                const resolution = 8; // Increased from 6 for better performance
                const fieldWidth = Math.ceil(width / resolution);
                const fieldHeight = Math.ceil(height / resolution);

                // Build spatial index for faster lookup
                const cellSize = config.metaballRadius;
                const gridCols = Math.ceil(width / cellSize);
                const gridRows = Math.ceil(height / cellSize);
                const spatialGrid = new Array(gridRows);
                for (let i = 0; i < gridRows; i++) {
                    spatialGrid[i] = new Array(gridCols);
                    for (let j = 0; j < gridCols; j++) {
                        spatialGrid[i][j] = [];
                    }
                }

                // Assign points to spatial grid
                for (const point of influencePoints) {
                    const gridX = Math.floor(point.x / cellSize);
                    const gridY = Math.floor(point.y / cellSize);
                    if (gridX >= 0 && gridX < gridCols && gridY >= 0 && gridY < gridRows) {
                        spatialGrid[gridY][gridX].push(point);
                    }
                }

                // Compute field values using metaball formula with spatial culling
                const field = new Array(fieldHeight);
                const radiusSq = config.metaballRadius * config.metaballRadius;

                for (let y = 0; y < fieldHeight; y++) {
                    field[y] = new Array(fieldWidth);
                    for (let x = 0; x < fieldWidth; x++) {
                        const px = x * resolution;
                        const py = y * resolution;

                        // Find which spatial grid cells to check
                        const minGridX = Math.max(0, Math.floor((px - config.metaballRadius) / cellSize));
                        const maxGridX = Math.min(gridCols - 1, Math.floor((px + config.metaballRadius) / cellSize));
                        const minGridY = Math.max(0, Math.floor((py - config.metaballRadius) / cellSize));
                        const maxGridY = Math.min(gridRows - 1, Math.floor((py + config.metaballRadius) / cellSize));

                        let value = 0;

                        // Only check nearby grid cells
                        for (let gy = minGridY; gy <= maxGridY; gy++) {
                            for (let gx = minGridX; gx <= maxGridX; gx++) {
                                const nearbyPoints = spatialGrid[gy][gx];

                                for (const point of nearbyPoints) {
                                    const dx = px - point.x;
                                    const dy = py - point.y;
                                    const distSq = dx * dx + dy * dy;

                                    if (distSq < radiusSq && distSq > 0.1) {
                                        // Metaball falloff function: r²/d²
                                        value += radiusSq / distSq;
                                    } else if (distSq <= 0.1) {
                                        // Very close to center - max value
                                        value += radiusSq / 0.1;
                                    }
                                }
                            }
                        }

                        field[y][x] = value;
                    }
                }

                // Use compositing for smooth blending
                ctx.save();

                // Reuse or create temporary canvas for metaball rendering
                if (!this.metaballCanvas || this.metaballCanvas.width !== width || this.metaballCanvas.height !== height) {
                    this.metaballCanvas = document.createElement('canvas');
                    this.metaballCanvas.width = width;
                    this.metaballCanvas.height = height;
                    this.metaballCtx = this.metaballCanvas.getContext('2d', { alpha: true, willReadFrequently: false });
                }

                const tempCtx = this.metaballCtx;
                tempCtx.clearRect(0, 0, width, height);

                // Batch rendering by collecting rectangles of similar colors
                const threshold = config.metaballThreshold;

                for (let y = 0; y < fieldHeight; y++) {
                    for (let x = 0; x < fieldWidth; x++) {
                        const value = field[y][x];

                        if (value > threshold) {
                            // Create smooth color gradient based on field strength
                            const intensity = Math.min(1, (value - threshold) / 3);
                            const alpha = Math.min(0.35, intensity * 0.35);

                            const r = Math.floor(149 - intensity * 100);
                            const g = Math.floor(165 - intensity * 100);
                            const b = Math.floor(166 - intensity * 100);

                            tempCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                            tempCtx.fillRect(x * resolution, y * resolution, resolution + 1, resolution + 1);
                        }
                    }
                }

                // Create land mask
                this.createLandMask();

                // Apply land mask to metaballs using destination-in compositing
                if (this.landMaskCanvas) {
                    tempCtx.globalCompositeOperation = 'destination-in';
                    tempCtx.drawImage(this.landMaskCanvas, 0, 0);
                    tempCtx.globalCompositeOperation = 'source-over';
                }

                // Apply blur for smoother metaballs
                ctx.filter = 'blur(6px)';
                ctx.globalCompositeOperation = 'multiply';
                ctx.drawImage(this.metaballCanvas, 0, 0);
                ctx.globalCompositeOperation = 'source-over';
                ctx.filter = 'none';

                ctx.restore();
            }

            render() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw old sites trail (faded gray points)
                if (config.showTrail) {
                    const oldSites = this.getOldSites();

                    // Draw network connections between old sites
                    if (config.showNetwork && oldSites.length >= 2) {
                        const networkPoints = oldSites.map(site => {
                            const point = this.map.latLngToContainerPoint([site.lat, site.long]);
                            return {
                                x: point.x,
                                y: point.y,
                                id: site.id,
                                lat: site.lat,
                                long: site.long
                            };
                        }).filter(p =>
                            p.x >= -200 && p.x <= this.canvas.width + 200 &&
                            p.y >= -200 && p.y <= this.canvas.height + 200
                        );

                        if (networkPoints.length >= 2) {
                            // Use cached network computation (or pre-computed)
                            const networkData = this.computeNetwork(networkPoints, state.currentTime);
                            const edges = networkData.edges || networkData; // Handle both old and new format
                            const metaballPoints = networkData.metaballPoints || null;

                            // Draw metaballs visualization
                            if (config.showMetaballs) {
                                this.renderMetaballs(edges, metaballPoints);
                            }

                            // Draw network edges
                            if (!config.showMetaballs) {
                                ctx.strokeStyle = 'rgba(140, 140, 140, 0.5)';
                                ctx.lineWidth = 1.5;
                                ctx.setLineDash([3, 3]);

                                edges.forEach(edge => {
                                    ctx.beginPath();
                                    ctx.moveTo(edge.p1.x, edge.p1.y);
                                    ctx.lineTo(edge.p2.x, edge.p2.y);
                                    ctx.stroke();
                                });

                                ctx.setLineDash([]);
                            }

                            // Draw precomputed network lines on top (if enabled)
                            if (config.showPrecomputedLines && this.currentSnapshot && this.currentSnapshot.edges) {
                                ctx.strokeStyle = 'rgba(80, 120, 180, 0.7)';
                                ctx.lineWidth = 2;
                                ctx.setLineDash([5, 5]);

                                this.currentSnapshot.edges.forEach(edge => {
                                    // Draw full LCP path if available
                                    if (edge.path && edge.path.length > 0) {
                                        ctx.beginPath();
                                        edge.path.forEach((point, i) => {
                                            const p = this.map.latLngToContainerPoint([point[0], point[1]]);
                                            if (i === 0) {
                                                ctx.moveTo(p.x, p.y);
                                            } else {
                                                ctx.lineTo(p.x, p.y);
                                            }
                                        });
                                        ctx.stroke();
                                    } else {
                                        // Fallback to straight line
                                        const p1 = this.map.latLngToContainerPoint([edge.from_lat, edge.from_lng]);
                                        const p2 = this.map.latLngToContainerPoint([edge.to_lat, edge.to_lng]);
                                        ctx.beginPath();
                                        ctx.moveTo(p1.x, p1.y);
                                        ctx.lineTo(p2.x, p2.y);
                                        ctx.stroke();
                                    }
                                });

                                ctx.setLineDash([]);
                            }
                        }
                    }

                    // Draw old sites as small gray dots
                    oldSites.forEach(site => {
                        const point = this.map.latLngToContainerPoint([site.lat, site.long]);

                        // Skip if off-screen
                        if (point.x < -50 || point.x > this.canvas.width + 50 ||
                            point.y < -50 || point.y > this.canvas.height + 50) {
                            return;
                        }

                        ctx.fillStyle = 'rgba(150, 150, 150, 0.4)';
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }

                // Draw active sites
                const visibleSites = this.getVisibleSites();

                // Sort by recency (oldest first, so newest draws on top)
                visibleSites.sort((a, b) => b.calBP - a.calBP);

                visibleSites.forEach(site => {
                    const point = this.map.latLngToContainerPoint([site.lat, site.long]);

                    // Skip if off-screen
                    if (point.x < -50 || point.x > this.canvas.width + 50 ||
                        point.y < -50 || point.y > this.canvas.height + 50) {
                        return;
                    }

                    this.drawSite(ctx, point.x, point.y, site);
                });
            }

            drawSite(ctx, x, y, site) {
                const color = economyColors[site.economy] || economyColors.other;
                const radius = site.radius;
                const opacity = site.opacity;

                // Highlight if hovered
                const isHovered = state.hoveredSite && state.hoveredSite.id === site.id;

                // Outer glow for recent sites
                if (site.recency > 0.5) {
                    const glowRadius = radius + 1;
                    const gradient = ctx.createRadialGradient(x, y, radius, x, y, glowRadius);
                    gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, ${opacity * 0.5})`);
                    gradient.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, glowRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Main circle
                ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${opacity * 0.85})`;
                ctx.strokeStyle = isHovered ? '#000' : '#fff';
                ctx.lineWidth = isHovered ? 2 : 0.5;

                ctx.beginPath();
                ctx.arc(x, y, isHovered ? radius * 1.5 : radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }

            getSiteAtPosition(x, y) {
                const visibleSites = this.getVisibleSites();

                // Check from newest to oldest (reverse rendering order)
                for (let i = 0; i < visibleSites.length; i++) {
                    const site = visibleSites[i];
                    const point = this.map.latLngToContainerPoint([site.lat, site.long]);

                    const dx = x - point.x;
                    const dy = y - point.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance <= site.radius + 2) {
                        return site;
                    }
                }

                return null;
            }
        }
    </script>
</body>

</html>
